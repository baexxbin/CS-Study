## 트랜잭션

데이터에 대한 하나의 논리적인 작업 단위

<br/>

## 트랜잭션이 안전하게 수행된다는 것을 보장하기 위한 성질(ACID)

1. **Atomicity(원자성)** : 한 마디로 All or Nothing. 설정된 트랜잭션 범위 안의 내용들이 모두 DB에 반영되거나 전혀 반영되지 않아야 한다.
2. **Consistency(일관성)** : DB의 상태가 트랜잭션 이전과 이후에 일관성을 유지한다는 의미다. 만약 DB의 제약조건에 위배되는 트랜잭션이라면 트랜잭션은 실행되지 않고 중단된다.
3. **Isolation(독립성)** : 여러 트랜잭션이 있을 때, 각각의 트랜잭션은 다른 트랜잭션의 연산에 끼어들지 못하고 독립적이다. A 라는 계좌이체 트랜잭션이 진행중이라면, B 라는 계좌이체 트랜잭션은 동시에 작업할 수 없다.
4. **Durability(영구성)** : 트랜잭션이 성공했다면 시스템의 문제 등 어떤 문제가 있더라도, 결과는 반영돼야 한다.

<br/>

## ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?

**Durability(영구성)**을 달성하기 위해, 미리 쓰기 로깅(WAL - Write Ahead Logging)을 사용한다. WAL에서는 실제 데이터베이스를 수정하기 전에 DBMS가 변경 사항을 디스크의 로그 파일에 기록한다. 변경 사항이 로그에 안전하게 기록되면 DBMS가 데이터베이스를 업데이트한다. 시스템 충돌과 같은 장애가 발생하면 DBMS는 기록된 트랜잭션을 재생하고 데이터를 일관된 상태로 복원하여 데이터베이스를 복구할 수 있게된다.

<br/>

## 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?

데이터의 무결성을 보장해야하는 경우에 사용한다. 데이터의 상태를 바꾸는 작업에 트랜잭션을 쓴다. 쉬운 예로는 재고, 잔고 관리 등이 있다.

<br/>

## 읽기에는 트랜잭션을 걸지 않아도 될까요?

읽기 연산을 수행할 때 트랜잭션이 반드시 필요한 것은 아니다. 트랜잭션이 없어도 읽기는 가능하다.

하지만 동시성 문제가 발생할 수 있다. a 라는 데이터에 하나의 요청은 읽기 요청이고, 다른 요청은 쓰기 요청일때 데이터의 일관성을 보장할 수 없다. 그렇기에 트랜잭션을 걸어줘 동시성을 만족시켜줘야 한다. 

트랜잭션은 베타락을 이용해 다른 트랜잭션이 리소스에 접근을 못하게 함으로써 동시성을 보장하지만, 다른 트랜잭션은 대기 상태에 놓이기에 성능에 영향을 미칠 수 있다.

만약 읽기 작업만 필요한 경우에는 readOnly = ture 주석을 걸어줘서 읽기 연산에 최적화 시킬 수 있다. 이 주석은 다른 트랜잭션의 접근이 가능한 공유락을 걸어주기 때문이다. 그렇기에 위의 트랜잭션 설정과 다르게 대기 하지 않고 공유 리소스에 접근이 가능하다. 

<br/>

## Transaction Isolation Level 4가지

1. **READ-UNCOMMITTED** : 커밋이 끝나지 않은 데이터를 다른 트랜잭션이 읽을 수 있다. 예를 들어 A,B 순서로 진행중인 트랜잭션이 있다. 트랜잭션 A가 커밋하지 않은 데이터에 트랜잭션 B가 접근해 데이터 값을 읽을 수 있다. 이 경우에 진행중인 트랜잭션 A는 롤백될수도 있기에 데이터 값은 달라질 수 있다. 이렇게 신뢰할 수 없는 데이터를 읽는 것을 DIRTY READ 라고 한다. 즉, 데이터 정합성에 많은 문제가 있기에 실제론 거의 사용하지 않는다.
2. **READ-COMMITTED** : 커밋이 끝난 데이터만 다른 트랜잭션이 읽을 수 있다. 커밋을 하지 않은 데이터에는 접근이 불가하다. 예를 들어 A,B 순서로 진행중인 트랜잭션이 있다. 트랜잭션 A가 아직 커밋하지 않았다면, 트랜잭션 B는 트랜잭션 A가 시작되기 전 데이터를 읽어온다. 그리고 A가 커밋이 끝나면 다시 같은 데이터의 값을 읽어온다. 이렇기에 트랜잭션 시작 전, 후 데이터 값이 다를 수 있다. 즉, Non-Repeatable Read 가 발생할 수 있다.
3. **REPEATABLE-READ** : 하나의 트랜잭션 내에서 동일 select 쿼리를 실행했을 때, 항상 같은 결과를 가져와야 한다. 이 경우는 데이터가 변경되더라도 같은 데이터를 읽게 해주는 것이다. A 트랜잭션이 select 한 특정 데이터 값이 트랜잭션 B에 의해 값이 바뀌고 B가 커밋까지 되었어도 트랜잭션 A는 처음 select 했던 데이터 값을 가져온다. 이처럼 수정 등의 요청이 발생할 경우에는 원하는 데이터가 안 나올 수 있다. 그렇기에 DB 는 수정 요청에 대해서는 순차적으로 처리하거나 수정할 row 를 미리 잠금으로써 방지한다.
4. **SERIALIZABLE** : 하나의 트랜잭션에서 작업 중인 데이터는 다른 트랜잭션에서 접근할 수 없다. 철저한 독립성을 보장하며 동시성을 허용하지 않는다.
