# 트랜잭션(Transaction)

<br/>

- 데이터베이스의 상태를 변화시키기 위해 논리적인 기능을 수행하는 작업 단위
  - 상태를 변화시킨다는 것은 `SQL 질의어`를 통해 DB에 접근하는 것으로, 쿼리를 날려 연산을 수행하는 것
  - `SQL 질의어`: SELECT, INSERT, DELETE, UPDATE
- 또는, 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미함
- 트랜잭션은 상황에 따라 여러 개가 만들어질 수 있고, 각 트랜잭션들은 상황에 따라 저장(`Commit`)되거나 철회(`Rollback`)될 수 있음

<br/>

### 트랜잭션의 필요성

> 트랜잭션은 데이터베이스에서 하나의 거래를 안전하게 처리하도록 보장해주는 방법(`작업의 안전성 보장`)

- 사용자가 계좌이체를 한다고 가정해보자.
  - 사용자 A가 사용자 B에게 송금하려고 할 때, 알 수 없는 오류가 발생하여 사용자 A의 계좌에서는 돈이 빠져나갔지만 사용자 B의 계좌에는 입금이 되지 않는 상황이 발생할 수 있다.
  - 이와 같은 상황을 막기 위해서 거래가 성공적으로 모두 끝나야 완전한 거래로 승인하고, 거래 도중에 오류가 발생하면 이 거래를 완전히 되돌려서 거래의 안전성을 확보할 수 있다.
  - 위의 방법이 트랜잭션이다.
- 이때 DB의 작업
  1. 사용자 A의 계좌에서 돈을 차감한다 : UPDATE 문을 사용해 사용자 A의 잔고를 변경
  2. 사용자 B의 계좌에 돈을 추가한다 : UPDATE 문을 사용해 사용자 B의 잔고를 변경
- 현재의 작업 단위(트랜잭션): 출금 UPDATE문 + 입금 UPDATE문
  - 위 두 쿼리문 모두 성공적으로 완료되어야만 `하나의 작업(트랜잭션)`이 완료되는 것(`Commit`)
  - 작업 단위에 속하는 쿼리 중 하나라도 실패하면 모든 쿼리문을 취소하고 이전 상태로 돌려놓아야함(`Rollback`)


<br/>
<br/>

## 트랜잭션의 성질(ACID)

> 데이터베이스 내에서 일어나는 하나의 트랜잭션의 안전성을 보장하기 위해 필요한 성질
> - 원자성, 일관성, 독립성, 영구성

<br/>

#### 원자성(Atomicity)

- 트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장(All or Nothing)
- 트랜잭션의 연산은 설정된 트랜잭션 범위 안의 내용들이 데이터베이스에 모두 반영되거나 아니면 전혀 반영되지 않아야 함
- 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽하게 수행되지 않고 하나라도 오류가 발생하면 트랜잭션은 전부 취소 되어야 함
- 원자성은 수행하고 있는 트랜잭션에 의해 변경된 내역을 유지하면서, 이전어 커밋된 상태를 임시 영역에 따로 저장함으로써 보장함
  - 현재 수행하고 있는 트랜잭션에서 오류가 발생하면 현재 내역을 날리고 임시 영역에 저장해뒀던 상태로 rollback함
    - `롤백 세그먼트(rollback segment)`: 이전 데이터들이 임시로 저장되는 영역
  - 일반적으로 Rollback을 명시하면 INSERT, DELETE, UPDATE 등의 작업 전체가 취소되는데, 확실하게 오류가 발생하지 않은 부분도 다시 처음부터 작업을 수행해야 함(문제)
    - 이러한 부분을 해결하기 위해 중간 저장 지점인 `save point`를 지정하여 해결가능
    - `save point`를 사용하면 전체가 아닌 특정 부분에서 트랜잭션을 취소시킬 수 있음

<br/>

#### 일관성(Consistency)

- 데이터베이스의 상태가 트랜잭션의 작업 처리 이전과 이후에 항상 일관성을 유지하는 것을 보장
- 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태를 유지해야 함
- 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 함
- 트랜잭션에서는 [트리거](https://github.com/jmxx219/CS-Study/blob/main/Database/%ED%94%84%EB%A1%9C%EC%8B%9C%EC%A0%80%EC%99%80%20%ED%8A%B8%EB%A6%AC%EA%B1%B0.md#%ED%8A%B8%EB%A6%AC%EA%B1%B0trigger)를 통해서 일관성을 보장함
  - 트리거는 특정 테이블에 쿼리 작업과 같은 이벤트가 발생했을 때, 사용자가 직접 호출하는 것이 아닌 데이터베이스에서 자동으로 호출하여 동작하도록 하는 것
  - ex) 데이터베이스에서는 정보의 수정이 일어났을 경우에 다른 테이블도 함께 정보가 수정될 수 있도록 명시적으로 자동 업데이트하는 명령을 구성함

<br/>


#### 독립성, 격리성(Isolation)

- 트랜잭션 수행 시, 다른 트랜잭션의 작업이 끼어들지 못하도록 보장
- 둘 이상의 트랜잭션이 동시에 실행될 경우, 어떤 하나의 트랜잭션이 다른 트랜잭션의 연산에 끼어들 수 없음
- 수행중인 트랜잭션이 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없음
- [트랜잭션의 격리성 참고](https://github.com/jmxx219/CS-Study/blob/main/Database/%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%EC%9D%98%20%EA%B2%A9%EB%A6%AC%EC%84%B1.md)

<br/>


#### 영구성, 지속성(Durability)

- 성공적으로 수행된 트랜잭션은 영원히 반영되는 것을 보장
- 시스템이 고장나거나 어떤 문제가 발생하더라도 성공적으로 완료된 트랜잭션의 결과는 영구적으로 반영되어야 함
- DBMS에서는 영구성을 보장하기 위해 `미리 쓰기 로깅(WAL - Write Ahead Logging)`을 사용함
  - WAL에서는 실제 데이터베이스를 수정하기 전에 DBMS가 변경 사항을 디스크의 로그 파일에 기록함
  - 변경 사항이 로그에 안전하게 기록되면 DBMS가 데이터베이스를 업데이트함
  - 이후, 시스템 충돌과 같은 장애가 발생하면 DBMS는 기록된 트랜잭션을 재생하고 데이터를 일관된 상태로 복원하여 데이터베이스를 복구할 수 있음


<br/>
<br/>


## 트랜잭션의 연산 및 상태


### 트랜잭션의 연산
- 커밋(Commit) 연산
  - 한 개의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝났고 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산
- 롤백(Rollback) 연산
  - 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산
  - Rollback 시에는 해당 트랜잭션을 재시작하거나 폐기함

<br/>

### 트랜잭션의 상태

- `활동(Active)`: 트랜잭션이 실행 중인 상태
- `실패(Failed)`: 트랜잭션이 실행되다가 오류가 발생하여 중단된 상태
- `철회(Aorted)`: 트랜잭션이 비정상적으로 종료되어 Rollback 연산을 수행한 상태
- `부분 완료(Partially Committed)`: 트랜잭션의 마지막 연산까지 실행했고, Commit 연산이 실행되기 직전 상태
- `완료(Committed)`: 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태


<br/>
<br/>


### Ref

- [[DataBase] 트랜잭션(Transaction)이란?](https://dev-coco.tistory.com/72)