# B-Tree와 B+Tree

### Tree 구조
- 트리 구조는 데이터베이스뿐만 아니라 시스템 세계에서 데이터를 유지하기 위해 자주 사용하는 구조
  - 탐색 시, 단 시간 내에 실행할 수 있기 때문
- `B-Tree`와 `B+Tree`
  - 더 효율적으로 원하는 데이터를 탐색할 수 있는 자료구조의 일종
  - 주로 데이터베이스의 인덱스를 사용할 때 쓰이는 알고리즘

<br/>

## B-Tree

- 이진 트리의 확장된 버전으로, 균형 트리임
  - 하나의 노드에 여러 개의 값을 가질 수 있음
  - 하나의 노드가 2개 이상의 자식 노드를 가질 수 있음
    - 최대 자식 수의 개수에 따라 1, 2, 3, .. M차 B-tree가 있음
  - 전체적으로 트리의 균형을 유지해 밸런스를 맞춰줌
- 데이터가 정렬된 상태로 유지되어 있음(핵심)
  - key 값을 이용해 찾고하는 데이터를 트리 구조를 이용해 찾음
- B-tree는 `어떤 값에 대해서도 같은 시간에 결과를 얻을 수 있다`는 `균일성` 장점을 가짐

<br/>

#### B-tree 조건
- 모든 노드들은 최대 m개의 자식을 가질 수 있음
- k개의 자식을 가진 리프가 아닌 노드는 k-1개의 키를 가지고 있음
- 모든 내부 노드는 최소 [m/2]개의 자식을 가져야 함
- 모든 리프 노드들은 같은 레벨에 있어야 함
- 리프가 아닌 모든 노드들은 최소 2개 이상의 자식을 가져야 함

<br/>

#### 균형 트리
- 균형 트리(Balanced-Tree)는 루트 노드부터 리프 노드까지의 거리가 일정한 트리 구조
  - 탐색 성능을 높이기 위해 균형 있게 높이를 유지
- 균형을 유지할 경우, 어떤 데이터를 검색할 때 빠른 속도로 데이터를 찾을 수 있음
- 일반적인 트리인 경우, 탐색하는데 평균적으로 O(logN) 시간 복잡도를 가지지만, 트리가 편향되어 있으면 최악의 시간 복잡도로 O(N)을 가짐
  - 이러한 단점을 보완하기 위해 트리가 편향되지 않도록 항상 밸런스를 유지하는 트리가 필요(균형 트리)
  - 자식들의 밸런스를 잘 유지하면 최악의 경우에도 O(logN) 시간 복잡도를 가짐
- ex) RedBlack-Tree(RBT), B-Tree

<br/>


## B+Tree

- B-tree를 개선해서 등장
- 모든 리프 노드들은 링크드 리스트 형태로 이어져 있음
  - full scan 시, 리프 노드들만 순차 탐색하면 되기 때문에 탐색에 유리함
  - B-tree는 탐색 시, 모든 노드를 탐색해야 함
- 실제 데이터는 리프 노드에만 저장됨
  - 내부 노드들은 단지 키만 가지고 있고, 올바른 리프 노드로 연결해주는 라우팅 기능을 함
  - B-tree에 비해 같은 노드에 더 많은 키를 저장할 수 있음
- 중복 키를 가짐
  - 내부 노드들이 데이터를 가지고 있지 않기 때문에 리프 노드들이 키와 데이터를 모두 가지고 있어야 함

<br/>

#### B+Tree 장점
- 리프 노드를 제외하고 데이터를 담아두지 않기 때문에 메인 메모리를 더 확보해 더 많은 key를 수용할 수 있음
  - 하나의 노드에 더 많은 key들을 담을 수 있기 때문에 트리의 높이는 더 낮아짐
  - cache hit를 높일 수 있음
- 풀 스캔 시, B+tree는 리프 노드에 데이터가 모두 있어 한 번의 선형 탐색만 하면 됨
  - B-tree에 비해 빠름

<br/>

### B-tree와 B+tree의 비교

|   비교    |          B-tree           |          B+tree           |
|:-------:|:-------------------------:|:-------------------------:|
| 데이터 저장  |  모든 내부, 리프 노드들이 데이터를 가짐   |       리프노드만 데이터를 가짐       |
|  검색 속도  |       모든 노드 검색, 느림        |       리프노드에서 선형 탐색        |
|  키 중복   |            없음             |            있음             |
|   삭제    | 내부 노드의 삭제는 보잡하고 트리 변경히 많음 | 어떠한 노드든 리프에 있기 때문에 삭제가 쉬움 |
| 링크드 리스트 |           존재 x            |    리프 노드는 링크드 리스트로 저장됨    |
|   높이    |     특정 갯수의 노드는 높이가 높음     | 같은 노드일 때 B-tree보다 높이가 낮음  |
|   사용    |       데이터베이스, 검색엔진        |     멀티레벨 인덱스, DB 인덱스      |


<br/>

## 데이터베이스에서의 B-Tree/B+Tree

### 인덱싱의 필요성
- DB에서 어떤 데이터를 가져올 때, 모든 데이터를 풀 스캔하여 가져오면 시간이 매우 오래걸림
- 특히 데이터베이스 시스템은 디스크 기반이기 때문에 I/O 작업에서 상당한 시간을 소모함
- 디스트가 느린 이유
  - 데이터를 읽기 위해서는 헤드를 움직여 데이터가 저장된 위치(트랙)을 찾아야 하고, 그 후 원하는 정보가 있는 섹터가 다가올 때가지 기다려야 함
  - 따라서 데이터베이스의 I/O 처리 작업은 이렇게 물리적인 작업을 거치기 때문에 다른 자원들보다 더 오랜 시간이 걸림

<br/>

#### 디스크

- 메인 메모리는 주요 저장소로, 제한적인 공간 때문에 모든 데이터를 저장할 수 없음
  - 따라서 보조 저장소를 사용하는데, 페이지라고 부르는 마그네틱 디스크에 저장해서 비용을 줄임
- 디스크에서 메모리로 데이터를 전송하기 위해서는 디스크 읽기를 해야 함
  - 페이지에서 하나의 데이터만 조회하고 싶어도, 디스크는 모든 페이지 접근을 수행함
- 디스크는 메인 메모리만큼 빠르지 않은데, 데이터 읽기를 할 때마다 탐색과 회전 대기가 있기 때문
  - 디스크에 접근이 많아질 수록, 검색에 필요한 시간은 길어짐
  ```
  탐색 시간(seek time): 데이터를 읽기 위해 헤드를 움직여 데이터가 저장된 위치(트랙)를 찾는데 소요되는 시간  
  회전 대기 시간(rotational latency time): 원하는 정보가 있는 섹터가 다가올 때까지 기다리는 시간
  ```
- DBMS는 B-tree의 인덱싱을 활용해 특정 데이터를 찾기 위한 읽기 작업의 빈도를 낮춤
  - 각각의 노드는 메모리에서 하나의 페이지를 담당하여 각 노드가 최소한 절반을 채워두도록 해 읽기 접근의 횟수를 줄임

<br/>


### DB는 여러 자료구조 중에 왜 B-Tree/B+Tree를 사용할까?

#### 자료구조
- 해시테이블
  - 탐색 시간이 제일 빠름
  - 모든 값이 정렬되어 있지 않기 때문에, 해시 테이블에서는 특정 기준보다 크거나 작은 값(부등호)을 찾을 수 없음
  - 따라서 기준 값보다 크거나 작은 요소들을 항상 탐색할 수 있어야 하는 DB 인넥스 용도로는 맞지 않음
- RedBlack-Tree(RBT)
  - B-tree와 큰 차이는 `하나의 노드가 가지는 데이터의 개수`
  - RedBlack-Tree는 무조건 하나의 노드에 하나의 데이터 요소만 가지고, B-Tree는 하나의 노드에 여러 개의 데이터 요소를 저장(배열처럼 저장되어 있음)함
    - B-Tree는 같은 노드 상 데이터를 탐색할 때는 포인터 접근이 아닌, 실제 메모리 디스크에서 바로 다음 인덱스의 접근을 함
    - 하지만 RedBlack-Tree는 각 노드마다 무조건 하나의 데이터만 가지기 때문에 데이터를 접근할 때 무조건 참조 포인터로 접근하게 됨
- 배열
  - 참조 포인터라는 개념이 없고, 모든 데이터가 메모리 상 차례대로 저장되어 있어 접근이 매우 빠름
  - 탐색 속도로만 본다면 B-Tree보다 훨씬 빠름
  - 해시 테이블과 다르게 정렬 상태로 유지할 수있어 부등호 연산에도 문제가 없음
  - 하지만 배열이 B-Tree보다 빠른 것은 `탐색`뿐임
    - 배열 내에서 데이터의 저장, 삭제가 일어나는 순간 훨씬 비효율적인 성능이 발생하게 됨

<br/>

**B-Tree의 배열 형식의 접근과 RedBlack-Tree의 참조 포인터 접근**
- 둘다 시간 복잡도는 O(logN)이지만, 이는 알고리즘 처리에 대한 이론적인 시간 계산 방식일 뿐임
  - 물리적, 절대적인 시간 개념으로는 배열 접근이 훨씬 빠름
- 참조 포인터로 접근
  - 참조 포인터로 메모리에 접근하는 것은 실제 메모리상 순서대로 저장이 되었든 안되었든, 접근하려는 주소를 연산을 통해 직접 알아내어야 함
  - 이는 주소를 알아내는데 CPU가 내부적으로 많은 연산을 하게 됨
- 배열 형식의 접근
  - 배열은 데이터들이 메모리 공간에 차례대로 저장되어 있으므로 접근할 주소를 바로 알 수 있음
  - 따라서 메모리 주소를 알아내는데 성능 영향이 없음
  - B-tree도 자식 노드를 접근할 때는 참조 포인터로 접근함
    - 하지만 하나의 노드가 가지는 데이터 개수가 많아질수록 포인터 개수는 확연히 줄어들고, 트리 내에서 데이터가 많아질수록 이러한 차이는 더욱 커짐
- 결국 포인터 접근 수의 차이로 B-Tree가 RedBlack-Tree보다 탐색 시간이 더 빠름

<br/>

#### 데이터베이스 인덱스로 적합한 자료구조인 B-tree
- 항상 정렬된 상태로 특정 값보다 크고 작은 부등호 연산에 문제가 없음
- 참조 포인터가 적어 방대한 데이터 양에도 빠른 메모리 접근이 가능함
- 데이터 탐색뿐만 아니라, 저장, 수정, 삭제에도 항상 O(logN)의 시간 복잡도를 가짐

<br/>

### InnoDB의 B+tree
- MySQL의 DB engine인 InnoDB는 B+tree로 인덱싱을 처리함
- InnoDB에서 사용된 B+tree
  - 같은 레벨의 노드끼리는 Linked List가 아닌 Double Linked List를 사용
  - 자식 노드로는 Single Linked List로 연결되어 있음
  - key의 범위마다 찾아가야할 페이지 넘버(포인터)가 있는데, 해당 페이지 넘버를 통해 곧바로 다음 노드로 넘어감
  - 리프 노드에서 디스크에 존재하는 데이터의 주소값을 구할 수 있고, Linked List 통해 탐색도 가능함


