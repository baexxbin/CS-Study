## 인덱스(Index)

추가적인 쓰기 작업과 저장 공간을 활용하여 **데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조** 

<br/>

**개념**
- 데이터베이스에서 컬럼(속성)을 기반으로 빠른 검색을 지원하기 위한 자료구조
- 특정 컬럼 값 기반으로 테이블 행에 대한 물리적인 위치를 찾아 매핑
- 테이블에 대한 보조 구조로써 생성되며, 원본 데이터와 별도로 관리
- 특정 컬럼에 인덱스 생성 시, 해당 컬럼의 데이터를 정렬 후 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장
- 컬럼 값, 물리적 주소를 (Key, value) 한 쌍으로 저장


<br/>

**장점**
- 테이블의 검색 속도와 성능 향상
    - 전반적인 시스템 부하를 줄임

- 데이터들이 정렬된 형태를 가짐
    - Full Table Scan(특정 데이터 검색을 위해 테이블 전체 조건과 비교) 작업 불필요
    - ORDER BY, MIN/MAX 작업의 빠른 수행


<br/>


**단점**
- 인덱스 관리를 위한 추가 작업 필요
    - 항상 정렬된 형태 유지를 위한 작업
        - 삽입(INSERT) : 새로운 데이터에 대한 인덱스 추가
        - 삭제(DELET) : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업 수행
        - 수정(UPDATE) : 기존의 인덱스 사용않음 처리 및 갱신된 데이터의 인덱스 추가

- 데이터 잦은 수정 작업시 성능 저하
    - 인덱스 제거가 아닌 '사용하지 않음'처리 남겨둬 수정 작업이 많은 경우 데이터에 비해 과도하게 인덱스 커짐

- 추가 저장공간의 필요

- 데이터 형식에 따른 성능 저하 발생 가능
    - 값의 range가 적은 컬럼(ex.나이, 성별)의 경우 인덱스 읽고, 많은 데이터 조회함으로 비효율적

<br/>

### Index 사용이 좋은 경우
- 규모가 큰 테이블
- 삽입, 수정, 삭제 작업이 적은 컬럼
- WHERE, ORDER BY, JOIN 등이 자주 사용된느 컬럼 
- 많은 조회와 정렬된 상태가 유용한 컬럼
- 데이터의 중복도가 낮은 컬럼


<br/>
<br/>



## 인덱스의 자료구조
인덱스를 구현하는 대표적인 자료구조로는 해시 테이블(Hash Table)과 B+Tree가 있다

<br/>

### 해시 테이블(Hash Table)
Key와 Value를 한 쌍으로 데이터를 저장하는 자료구조

* (key, value) 쌍 표현
* key값을 이용해 대응되는 value값을 구함
* 평균적으로 O(1)의 빠른 시간에 데이터 탐색 (해시 충돌의 변수 존재)

<br/>

**인덱스와 해시 테이블**
- (Key, value) = (컬럼의 값, 데이터의 위치)로 인덱스 구현
- 실제로 인덱스에서 잘 사용X
    - 해시 테이블은 등호(=)연산에 최적화
    - 데이터베이스에선 부등호(<,>) 연산이 자주 사용 됨
    - 해시 테이블 내 데이터들은 정렬되어있지 않으므로 특정 기준보다 크거나 작은 값을 빠른 시간 내 찾을 수 없음

<br/>

### B+Tree
기존의 B-Tree의 단점을 개선시킨 자료구조

- leaf node에만 데이터 저장
    - 중간 node에서 key를 올바르게 찾아가기 위해 key가 중복될 수 있음
    - leaf node끼리 LinkdedList로 연결
    
- leaf node가 아닌 node에는 자식 포인터만 저장

> B-Tree : 탐색 성능을 높이기 위해 균형있게 높이를 유지하는 Balanced Tree의 일종
> * 단점 : 한 데이터의 검색은 효율적이나, 모든 데이터를 한 번 순회 시 트리의 모든 노드를 방문해야 함

<br/>

**인덱스와 B+Tree**
- leaf node를 제외하고 데이터를 저장하지 않아 메모리 확보
    - 하나의 node에 더 많은 포인터 가짐 → 트리의 높이 낮아짐 → 검색속도 높임 
- Full scan 경우, 데이터가 저장된 left node간 linkded list연결로 선형시간 소요 (B-Tree 단점 개선)
- linkded list연결을 통해 '부등호를 이용한 순차 검색 연산' 효율적으로 해결

<br/>

## sdf
* 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요
* 앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?
* ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.
* 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?
* 그렇다면 외래키는요?
