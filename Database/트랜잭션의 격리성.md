## 트랜잭션의 격리성(Transaction Isolation)
트랜잭션은 서로
끼어들지 못한다는 정의가 있습니다. 근데 무조건 서로 접근이 불가능할까요?
그렇지 않습니다. 이 격리성은 여러가지 단계가 있으며 해당 단계에 따라 격리성과 동시성의
정도가 다릅니다. 트랜잭션이 순차적으로 실행이 되면 격리성은 높아지지만 동시성은 너무
낮아져서 성능이 안좋게됩니다. 격리성과 동시성은 반비례관계입니다. 격리성이 너무 높으면
동시성은 떨어지고 격리성이 너무 낮으면 동시성은 높아지게 되죠.
또한 이러한 단계들은 DB에서 이 단계를 조정할 수 있습니다.

<br/>

## 트랜잭션의 격리수준에 따른 현상

- 팬텀리드(phantom reads) : 한 트랜잭션 내에서 동일한 쿼리를 2번 이상 보냈을 때 해당 조회 결과가 다른 것
- 반복 가능하지 않은 조회(Nonrepeatable Reads) : 한 트랜잭션 내의 같은 행에 두 번 이상조회가 발생했는데, 그 값이 다른 것을 말합니다.
- 더티 리드(Dirty Reads) : 하나의 트랜잭션이 다른 트랜잭션의 아직 커밋되지 않은 데이터를 읽는 현상입니다. T1이
업데이트 이후 롤백을 하여 커밋되지 않은 데이터가 됬음에도 불구하고 T2는 이미 커밋이
되었다 라고 판단하게 됩니다.

<br/>

## 트랜잭션의 격리수준

1. SERIALIZABLE
    - 커밋 완료된 데이터에 대해서만 조회할 수 있으며 트랜잭션을 순차적으로 진행시키는 것을
말합니다. 여러 트랜잭션이 동시에 같은 행에 접근할 수 없습니다.
2. REPEATABLE_READ
    - 커밋 완료된 데이터에 대해서만 조회할 수 있으며 반복해서 행을 조회하더라도 똑같은 행을
보장하는 단계입니다. 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없도록
막아주지만 새로운 행을 추가하는 것은 막지 않음. 따라서 똑같은 범위 쿼리를 실행했을 때
이후에 추가된 행이 발견될 수도 있습니다. 이는 MySQL8.0의 innoDB 기본값이기도 합니다.
이는 팬텀리드가 일어날 수도 있는 상태를 말합니다.
3. READ_COMMITED 
   - 커밋 완료된 데이터에 대해서만 조회할 수 있으며 커밋이 되지 않은 정보는 읽지 못합니다.
   PostgreSQL, SQL Server, 오라클에서 기본값으로 설정되어 있습니다. 가장 많이 사용되는
   격리 수준입니다.
   - 팬텀리드, 반복 가능하지 않은 조회가 일어날 수도 있음.
4. READ_UNCOMMITED
    - 가장 낮은 격리 수준이며 가장 빠릅니다. 다른 트랜잭션이 커밋하지 않은 정보를 읽을 수
있습니다.
   - 팬텀리드, 반복 가능하지 않은 조회, 더티리드가 일어날 수도 있음.

<br/>

> COMMIT : 트랜잭션을 종료하고 다른 사용자에게 변경된 모든 사항을 보이게 함.

<br/>

## 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?

아니요, 모든 DBMS(Database Management System)가 네 가지 격리 레벨을 모두 구현하고 있는 것은 아닙니다. 이유는 다음과 같습니다:

1. 성능: 더 높은 격리 수준은 동시성을 제한하고 데이터 일관성을 유지하기 위해 추가적인 제어 및 동기화 메커니즘을 필요로 합니다. 이로 인해 처리 성능이 저하될 수 있습니다. 따라서 일부 DBMS는 기본적으로 낮은 격리 수준을 사용하며, 필요에 따라 더 높은 격리 수준을 선택할 수 있도록 설정을 제공합니다.

2. 데이터베이스 엔진의 특성: 일부 DBMS는 특정 격리 수준을 완전히 구현할 수 없는 데이터베이스 엔진의 제약이 있을 수 있습니다. 특히 분산 환경이나 복제된 데이터베이스 시스템에서 모든 격리 수준을 완벽하게 지원하기는 어려울 수 있습니다.

3. 트랜잭션 요구사항: 모든 애플리케이션의 트랜잭션 요구사항이 네 가지 격리 레벨을 모두 필요로 하는 것은 아닙니다. 일부 애플리케이션은 낮은 격리 수준에서도 충분한 일관성을 확보할 수 있으며, 더 높은 격리 수준은 추가적인 비용과 복잡성을 초래할 수 있습니다. 따라서 DBMS는 다양한 격리 수준을 제공하여 사용자가 필요에 맞게 선택할 수 있도록 합니다.

요약하면, DBMS는 모든 격리 레벨을 구현하지 않는 이유는 성능, 데이터베이스 엔진의 제약, 그리고 애플리케이션의 트랜잭션 요구사항에 따라 선택적으로 구현하고 제공하기 때문입니다.

<br/>

## 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.

1. Undo 영역:

   - Undo 영역은 트랜잭션의 롤백 작업을 지원하기 위해 사용되는 공간입니다. 
   - 트랜잭션이 실행되는 동안 변경된 데이터의 이전 버전(원래 값)을 저장합니다. 
   - Undo 영역은 InnoDB 스토리지 엔진에서 MVCC(Multi-Version Concurrency Control) 기능을 구현하는 데 사용됩니다. 
   - 트랜잭션이 롤백되면 Undo 영역의 데이터를 사용하여 변경된 내용을 이전 상태로 되돌립니다.

2. Redo 영역:

   - Redo 영역은 트랜잭션의 커밋 작업을 지원하기 위해 사용되는 공간입니다.
   - 트랜잭션에서 수행한 변경 작업들을 로그로 기록합니다. 
   - 이 로그는 데이터 파일에 변경 내용을 반영하기 전에 디스크에 안전하게 기록됩니다. 
   - Redo 로그는 시스템 장애나 비정상적인 종료 시에도 데이터의 일관성과 내구성을 보장하기 위해 사용됩니다. 
   - 시스템이 장애로부터 복구될 때, Redo 로그를 사용하여 변경 작업을 다시 적용하여 데이터를 복구합니다.

<br/>

#### MVCC

**개념**
- 동시 접근을 허용하는 데이터베이스에서 동시성을 제어하기위해 사용하는 방법 중 하나

**특징**
- 데이터에 접근하는 사용자는 접근한 시점에 DB의 Snapshot을 읽음
- Snapshot 데이터에 대한 변경이 커밋될 때 까지 변경사항은 다른 DB 사용자가 볼 수 없음 
- 데이터 업데이트 시 이전 데이터를 덮어씌우는 것이 아닌, **새로운 버전의 데이터 UNDO영역에 생성**
   - 하나의 데이터에 대한 여러 버전 존재
   - 사용자는 마지막 버전의 데이터를 읽음

- 일반적인 RDBMS보다 빠른 동작
   - 잠금을 필요로하지 않음
   - 데이터 읽을 때, 다른 사람이 데이터 삭제, 수정해도 영향받지 않고 데이터 사용 가능
- 사용않는 데이터의 누적으로 데이터 정리 시스템 필요
- 데이터 버전 충돌 시 애플리케이션 영역에서 해결해야함

<br/>
<br/>

## 스토리지 엔진이 정확히 무엇을 하는 건가요?

스토리지 엔진은 데이터베이스 시스템에서 데이터를 저장, 관리, 액세스하는 역할을 담당하는 핵심 구성 요소입니다. 스토리지 엔진은 데이터 파일의 생성과 관리, 인덱스 구조의 유지, 데이터의 읽기 및 쓰기 작업 처리 등을 담당합니다.

일반적으로 데이터베이스 시스템은 다양한 스토리지 엔진을 제공하며, 각각의 엔진은 데이터를 저장하는 방식, 인덱스 구조, 액세스 방법 등에서 차이가 있습니다. 스토리지 엔진을 선택하면 해당 엔진의 특성과 기능을 활용하여 데이터의 성능, 확장성, 일관성 등을 조절할 수 있습니다.

스토리지 엔진의 주요 역할은 다음과 같습니다:

1. 데이터 저장과 관리:

   - 스토리지 엔진은 데이터베이스의 데이터 파일을 생성하고 관리합니다.
   - 데이터 파일에는 테이블, 인덱스, 뷰, 프로시저 등의 데이터와 구조 정보가 저장됩니다.
   - 스토리지 엔진은 데이터 파일의 생성, 확장, 축소, 삭제 등을 관리하여 데이터의 저장 공간을 효율적으로 관리합니다.

2. 인덱스 구조 관리:

   - 스토리지 엔진은 인덱스를 생성하고 유지 관리합니다.

   - 인덱스는 데이터베이스의 검색 성능을 향상시키기 위해 사용되며, 특정 열 또는 열의 조합에 대한 빠른 검색을 지원합니다.

   - 스토리지 엔진은 인덱스의 구조를 관리하고 업데이트하여 데이터의 검색 성능을 최적화합니다.

3. 데이터 액세스:

   - 스토리지 엔진은 데이터의 읽기 및 쓰기 작업을 처리합니다.

   - 읽기 작업은 데이터를 검색하고 반환하는 작업을 의미하며, 쓰기 작업은 데이터를 변경하거나 새로운 데이터를 추가하는 작업을 의미합니다.

   - 스토리지 엔진은 데이터의 액세스 방법과 접근 경로를 최적화하여 데이터 액세스의 성능을 향상시킵니다.

각각의 스토리지 엔진은 고유한 특성과 장단점을 가지고 있으며, 선택한 스토리지 엔진은 데이터베이스의 성능, 안정성, 확장성 등에 큰 영향을 미칩니다. 따라서 스토리지 엔진 선택은 데이터베이스 시스템의 설계와 운영에서 중요한 결정 사항 중 하나입니다.

<br/>

## innoDB와 myISAM 차이

Innodb은 MySQL 8.0의 기본 스토리지 엔진입니다. 그러나 MyISAM으로도 변경은
가능합니다.
1. InnoDB는 MyISAM 에 비해 데이터베이스 크기가 커짐에 따라 더 큰 가용성을 제공합니다.
2. 행, 인덱스 조회 캐싱 : MyISAM은 파일 시스템 블록 캐시에 의존하는 반면 InnoDB는 엔진
자체 내에서 행 캐시와 인덱스 캐시를 결합하여 이 작업을 수행합니다.
3. MyISAM은 테이블 수준의 잠금 제공, InnoDB는 행 수준 잠금을 사용합니다.
4. MyISAM은 항상 테이블에 ROW COUNT를 가지고 있어 조회 쿼리시 빠릅니다.
5. InnoDB는 트랜잭션 처리, 대용량 데이터를 다루기에 좋고 트랜잭션이 필요없고 조회기능이
많을 때 MyISAM이 좋습니다.

<br/>

## Wiredtiger 엔진 : MongoDB의 default엔진(3.2 이상부터)

wiredTiger 엔진은 LSMTree(로그 기반 병합트리)를 이용하여 읽기 성능을 포기하고 그만큼
저장 성능을 향상시키고 느린 읽기 성능을 보완하기 위해 블룸 필터를 사용한 엔진입니다.
MongoDB는 다음과 같은 특징들이 있는데 아래 특징들이 이 엔진 아래에서 관장됩니다.

1. 체크포인트 : MongoDB는 60초 간격으로 체크포인트를 생성, 또한 MongoDB가
종료되거나 새로운 체크포인트를 작성하는 동안 오류가 발생하더라도 다시 시작하면
MongoDB는 마지막 유효한 체크포인트에서 복구할 수 있습니다. 체크포인트를
기반으로 복구가 가능
2. 저널링 : 로깅라고 부를 수 있는 저널링이 가능. 체크포인트 간의 모든 데이터 수정
사항을 유지합니다. MongoDB가 체크포인트 사이에 종료되면 저널을 사용하여
마지막 체크포인트 이후 수정된 모든 데이터를 재생산 할 수 있음.
3. 압축 : WiredTiger를 통해 MongoDB는 모든 컬렉션 및 인덱스에 대한 압축을
지원합니다.
4. 메모리 : 약 50%의 메모리를 차지 예를 들어 총 4GB의 RAM이 있는 시스템에서
WiredTiger 캐시는 1.5GB의 RAM을 사용합니다( 0.5 * (4 GB - 1 GB) = 1.5 GB).
반대로 총 1.25GB의 RAM이 있는 시스템은 WiredTiger 캐시에 256MB를
할당합니다. 이는 전체 RAM의 절반에서 1기가바이트를 뺀 값( 0.5 * (1.25 GB - 1
GB) = 128 MB < 256 MB)이기 때문입니다.