# RDBMS, NoSQL의 클러스터링/리플리케이션 방식

<br/>

## Clustering(클러스터링)

<img src="https://github.com/jmxx219/CS-Study/assets/52346113/9f1a39f0-e2dc-4f1e-ac36-ad2d36983496" width="400" height="300"/>

- 개념
    - 여러 개의 DB를 `수평 구조`로 구축하는 방식(DB 서버 확장)
    - Fail Over(장애 극복) 시스템을 구축하기 위해 사용
        - DB가 동작하지 않으면, 전체 서비스가 동작할 수 없다는 문제점을 해결하기 위해 클러스터링을 이용하여 DB 서버를 늘림
    - `동기 방식`으로 노드들 간의 데이터 동기화
        - DB들 간의 데이터 무결성 검사(데이터가 일치하는지)를 하는 동기 방식으로 데이터를 동기화함
- 처리 방식
    1. 1개의 노드에 쓰기 트랜잭션이 수행되고, `COMMIT`을 실행함
    2. 실제 디스트에 내용을 쓰기 전에, 다른 노드로 데이터의 복제를 요청함
    3. 다른 노드에서 복제 요청을 수락했다는 신호(OK)를 보내고, 디스크에 쓰기를 시작함
    4. 다른 노드로부터 신호(OK)를 받으면 실제 디스크에 데이터를 저장함
- 장점
    - 노드들 간의 데이터를 동기화하기 때문에 항상 일관성있는 데이터를 얻을 수 있음
    - 1개의 노드가 죽어도 다르 노드가 살아 있어 시스템을 계속 장애 없이 운영할 수 있음
    - 여러 대의 DB 서버로 부하를 분산시켜 사용자의 요청을 더 많이 수용할 수 있음(`로드 밸런싱`)
    - 여러 대의 DB 서버를 가지므로, 높은 가용성을 보장함
        - DB 가용성: DB가 동작하고 있는 시간과 정지한 시간의 비율
        - DB 시스템을 구성할 서버나 스토리지 장비를 각가 2대 이상으로 구성해서, 한 쪽에 장애가 발생하더라도 단 시간내에 운용을 재개할 수 있도록 함
- 단점
    - 여러 노드들 간의 데이터를 동기화하는 시간이 필요하기 때문에, `Replication`에 비해 쓰기 성능이 떨어짐
    - 장애가 전파된 경우, 처리가 까다로우며 데이터 동기화에 의해 스케일링(확장)에 한계가 있음
- 종류
    - Active-Active Clustering
        - DB 서버를 `Active`(동작중) 상태로 두는 방식
        - 서버하나가 죽어도 다른 서버가 역할을 바로 수행하기 때문에 중단되는 시간이 없음
        - 여러 개의 서버가 하나의 스토리지를 공유함으로써 병목현상이 발생할 수 있음
            - 병목현상: 전체 시스템의 성능이나 용량이 하나의 구성요소로 인해 제한을 받는 현상
    - Active-StandBy Clustering
        - DB 서버 하나는 `Active`(동작중), 다른 하나는 `StandBy` 상태로 두는 방식
        - 운영중인 서버가 정지되었을 경우, `StandBy` 중인 서버를 `Active` 상태로 전환하여 문제에 대응할 수 있음
        - 서버가 한 대만 운영되기 때문에 병목 현상을 해결할 수 있음
        - 서버가 다운되었을 경우, 다른 서버가 `Active`로 전환되는데 시간이 들어, 서버가 중단되는 시간이 존재함


<br/>

## Replication(리플리케이션)

<img src="https://github.com/jmxx219/CS-Study/assets/52346113/1e43e45b-b069-4bc2-8601-e96431afa2e6" width="400" height="300"/>

- 개념
    - 여러 개의 DB를 권한에 따라 `수직 구조`(Master-Slave)로 구축하는 방식
        - 두 개 이상의 DBMS 시스템을 Master/Slave로 나눠서 동일한 데이터를 저장함
        - `Master Node`는 쓰기 작업만 처리(수정사항 반영)하며 `Slave Node`는 읽기 작업만 처리(실제 데이터 복사)함(기존의 부하를 분산)
    - DB 서버와 DB 스토리지 모두 확장
    - `비동기 방식`으로 노드들간의 데이터를 동기화함(Mysql은 기본적으로 비동기 방식)
        - Master와 Slave간의 데이터 무결성 검사(데이터가 일치하는지)를 하지 않는 비동기방식으로 데이터를 동기화함
- 처리 방식
    1. Master 노드에 쓰기 트랜잭션이 수행됨
    2. Master 노드는 데이터를 저장하고 트랜잭션에 대한 로그를 파일에 기록함(BIN LOG)
    3. Slave 노드의 IO Thread는 Master 노드의 바이너리 로그 파일(BIN LOG)을 릴레이 로그 파일(Replay Log)에 복사함
    4. Slave 노드의 SQL Thread는 파일(Replay Log)를 한 줄씩 읽으며 데이터를 저장함
- 장점
    - DB 요청의 60~80% 정도가 읽기(`SELECT`) 작업이기 때문에 `Slave` DB 만으로도 충분히 성능을 높일 수 있음
    - 비동기 방식으로 운영되어 지연 시간이 거의 없음
- 단점
    - 노드들 간의 데이터 동기화가 보장되지 않아 일관성있는 데이터를 얻지 못할 수 있음
    - Master 노드가 다운되면 복구 및 대처가 까다로움
    - 테이블의 데이터가 엄청나게 많을 경우, Slave DB 서버를 N대로 늘려도 원하는 데이터를 데이블로부터 찾는데 많은 시간이 소요될 수 있음
        - 이때는 `Sharding` 방식을 활용함


**데이터 정합성 문제**

1. 비동기 복제(Asynchronous replication)

<img src="https://github.com/jmxx219/CS-Study/assets/52346113/8b612535-fca1-4094-bcb1-625ebf44fc58" width="600" height="300"/>

  - 비동기 리플리케이션은 Master/Slave 서버 간 데이터 동기화까지의 시간이 소요되기 때문에 데이터 정합성 문제가 발생할 수 있음

2. 반동기 복제(Semi-synchronous replication)

<img src="https://github.com/jmxx219/CS-Study/assets/52346113/7ace0417-e770-4691-92cb-a8c0dbfdd083" width="600" height="300"/>

  - Master DB가 Slave DB로부터 Replay Log 기록이 완료되었다는 ACK를 받고 트랜랙션을 진행하는 방식
      - Replay Log 복제 방식을 통해 Slave DB의 모든 데이터 복제 과정을 기다리지 않고, 여러 Slave 중 단 1대만이라도 Replay Log를 수신했다면, Master DB는 해당 트랜잭션을 완료함
      - Master DB가 Slave DB에게 DB 변경 내용을 언제 전달하냐에 따라서 AFTER_SYNC, AFTER_COMMIT 2가지 방식으로 구분됨
  - 비동기 리플리케이션 방식에 비해 더 많은 DB 성능저하가 발생하지만, Replay Log 보장으로 최소한의 데이터 정합성을 확보할 수 있음


<br/>


## Sharding(샤딩)
- 개념
    - 같은 테이블 스키마를 가진 데이터를 다수의 DB에 분산하여 저장하는 방법
        - 테이블을 특정 기준으로 나눠서 저장 및 검색함
    - 다수의 복제본으로 구성하고, 각 샤드에 어떤 데이터가 저장될 지를 `Shard Key`를 기준으로 분리
        - `Shard Key`를 어떻게 정의하느냐에 따라 데이터를 효율적으로 분산시키는 것이 결정됨
- 목적
    - DB 트래픽을 분산할 목적
        - 데이터가 급격히 증가하게 되거나 트래픽이 특정 DB로 몰리는 상황을 대비해서 빠르고 유연하고 안전하게 DB를 증설할 수 있게 함(DB 서버의 부하를 분산)
        - Scale-up(수직적 확장)에는 한계가 있고, Scale-out(수평적 확장)은 동기화라는 제약이 따름
        - DB 서버의 샤딩은 대규모 시스템 설계와 확정성 확보에 필수 불가결인 요소가 됨
- Shard Key 방식
    - Hash Sharding: 데이터를 어디에 넣을지 해싱 결과에 따라 DB 서버에 저장
    - Dynamic Sharding: 테이블 형식의 데이터를 바탕으로 샤드를 결정해서 저장
    - Entity Group: 관련된 데이터를 하나의 샤드로 사용하는 방식

<br/>


## Lock

- 개념
    - 데이터의 일관성을 보장하기 위한 방법으로, Transaction 처리의 동시성을 제어하기 위한 기능
    - 여러 커넥션에서 동시에 동일한 자원을 요청할 경우, 순서대로 한 지점에 하나의 커넥션만 변경할 수 있게 해주는 역할
- 종류
    - `Shared Lock`(공유락, Read Lock)
        - 데이터를 읽을 때(`Select`) 사용하는 Lock
        - 공유락을 설정한 경우, 추가로 공유락을 설정할 수는 있지만, 배타락은 설정할 수 없음
            - 한 프로세스가 보고 있는 데이터를 다른 프로세스가 볼 수는 있지만, 변경할 수는 없음
    - `Exclusive Lock`(배타락, Write Lock)
        - 데이터를 변경할 때(`Insert`, `Update`, `Delete`) 사용하는 Lock
        - 락이 해제되기 전에는 다른 공유락과 배타락을 설정할 수 없음(읽기와 쓰기 모두 불가능)

<br/>

### Deadlock(교착상태)

- 두 개 이상의 트랜잭션들이 동시에 진행될 때, 서로가 서로에 대한 Lock을 소유한 상태로 대기 상태로 빠져서 더 이상 진행하지 못하는 상황
    - 특정 자원(테이블 또는 행)의 Lock을 획득한 채, 다른 트랜잭션이 소유하고 있는 Lock을 요구하면 발생함
- 해결 방법
    - 트랜잭션 진행방향을 같은 방향으로 처리
        - 테이블A 업데이트 후, 테이블B 업데이트
    - 트랜잭션 처리 속도를 최소화
        - 트랜잭션 속도가 빠르면 commit 처리도 빠르게 되기 때문에 다른 트랜잭션에서 테이블이 잠길일이 없음
    - timeout을 이용하여 잠금해제 시간 조절
        - `SET LOCK_TIMEOUT`으로 잠금해제 시간을 설정하여 무기한 대기하지 않고 만료되어 다음 작업을 진행할 수 있음
- 일반적인 DBMS에서는 데드락 탐지(Deadlock detection) 기능을 제공함
    - 데드락이 발견되면 자동으로 해소해줌
    - 실제 데드락 상황이 아니더라도, 락에 대한 대기시간이 설정된 시간을 초과하면 데드락으로 처리됨