## Redis
`Remote Dictionary Server`

**개념**
- 원격(Remote)에 위치하고 프로세스로 존재하는 In-Memory기반의 딕셔너리(Key-value)구조 데이터 관리 Server 시스템

<br>

**특징**
- `Key-value 구조`
    - 비관계형 구조로 데이터를 `키-값`형태로 단순하게 저장하는 구조
    - 관계형 데이터베이스와 같이 쿼리 연산을 지원하지 않으나, 데이터의 **고속 읽기와 쓰기**에 최적화
    - NoSQL DBMS로 분류 됨

- `In-Memory 솔루션`
    - 다양한 데이터 구조체를 지원함
        - DB, Cache, Message Queue, Shared Memory용도로 사용될 수 있음
        - 메모리에 상주하며 서비스의 상황에 따라 DB 혹은 Cache로 사용될 수 있음
    - 일반DB와 같이 디스크(ssd)에 데이터를 쓰는 구조가 아닌 메모리(dram)에서 데이터를 처리함
        - 작업 속도가 상당히 빠름
    - 메모리 기반으로 데이터 저장 속도가 매우 빠름
        - 리스트형 데이터 입력과 삭제가 MySQL에 비해 10배 정도 빠름
        - 외부 저장 장치를 사용했다면 메모리와 외부 저장 장치와 병목현상 발생

- `Remote Data Storage`
    - 여러 서버에서 같은 데이터를 공유하고 보고 싶을 때 사용가능

- `Replication(Master-Slave 구조)`
    - Redis는 기본적으로 1개의 싱글 쓰레드로 수행됨
    - 안정적인 인프라 구축을 위해 Replication(Master-Slave 구조) 필수

- `영속성 옵션 제공`
    - 기본적으로 메모리 기반의 데이터베이스로 휘발성이란 특징이 있으나 영속성 옵션을 제공해 데이터의 지속성 보장
    - RDB(Redis DataBase) 스냅샷
        - 주기적으로 데이터를 디스크에 스냅샷 형태로 저장
        - `*.rdb` 형식으로 저장하며 해당 시점으로 복구 가능
        - 백업이나 서버 재시작 시의 데이터 손실을 방지하기 위해 사용
    - AOF(Append-Only File) 로그 파일
        - 모든 쓰기 연산을 AOF 파일에 기록하는 방식 사용 가능
        - 주로 RDB 스냅샷보다 더 정확한 복구를 위해 사용
- 읽기 성능 증대를 위해 서버 측 복제를 지원
- 쓰기 성능 증대를 위해 클라이언트 측 샤딩을 지원
- 다양한 프로그래밍 언어 프레임워크 API 및 다양한 자료구조 지원

<br>

### Redis 사용 이유

- Collection 제공
    - Sorted Set
        <img src="https://blog.kakaocdn.net/dn/eCdBbM/btrFUUet1im/rflmRkbVwQfqDQK6dep8Pk/img.png" width="400" height="200"/>

        - 메모리에서 바로 가져와 사용하기에 디스크에 직접 접근하지 않아도됨
        - 정렬된 상태의 자료구조를 지원하기 때문에 빠르게 메모리에서 데이터를 가져와서 사용자에게 보여줄 수 있음
    - Key-Value
        - 간단한 key-value 형태로 redis에서 데이터 가져옴

- Atomic한 자료구조
    - Atomic한 자료 구조를 가지고 싱글 스레드로 동작해 race condtion 방지
    - 하지만 중복 요청 처리 등의 상황시 race condition 발생가능

<br>

### Redis 활용 사례

- 세션 캐싱 및 인증 토큰등 저장
- 전체 페이지 캐시
- 메시지 대기열 어플리케이션
- 랭킹 보드
- 좋아요 같은 빠른 데이터 처리를 요하는 시스템

<br>
<br>

> Redis는 RDBMS의 캐시 솔루션으로 사용 용도가 굉장히 높다

### 캐시(Cache)

**개념**
- 데이터나 값을 미리 복사해놓는 임시 저장소
- 한번 조회된 데이터를 미리 특정 공간에 저장해놓고, 똑같은 요청 발생 시 저장해놓은 데이터를 제공해 빠른 서비스를 제공하는 것 

<br>

**DB와 캐시**
- DB는 데이터를 물리 디스크에 직접 씀
    - 서버에 문제가 발생해도 데이터가 손실되지 않음
    - 매 트랜잭션마다 디스크에 접근해야하므로 부하가 많아지면 성능이 떨어짐
- DB Scale In, Scale Out 방식 이외에도 `캐시 서버`의 사용 검토
- Redis Cache
    - 메모리 단(In-Memory) 위치
    - 용량은 적지만 빠른 접근 속도
    - 저장하려는 데이터 셋이 주어진 메모리 크기보다 클땐 디스크 사용이 유리

<br>

**캐시 전략**           

캐시전략은 웹 서비스 환경에서 성능향상을 기대할 수 있는 중요한 기술.                
캐시 이용시 `데이터 정합성` 문제가 발생하므로, 적절한 `캐시 일기 전략`과 `캐시 쓰기 전략`을 통해 데이터 불일치 문제를 극복하며 빠른 성능을 유지한다.

[캐싱 전략 패턴 종류](https://inpa.tistory.com/entry/REDIS-📚-캐시Cache-설계-전략-지침-총정리#)

<br>

`주로 사용되는 캐시 전략 패턴`

**캐시 전략 패턴**

- 읽기 전략
    - `Look Aside 패턴`
    <img src="https://github.com/jmxx219/CS-Study/assets/50795805/e40b9698-fca1-4a23-9a22-1248fe4b71b8" width="400" height="200"/>

    - 개념
        - 데이터를 찾을때 우선 캐시에 저장된 데이터가 있는지 우선적으로 확인하는 전략
        - 캐시의 데이터가 없다면 DB를 조회해서 데이터를 읽어옴
    - 특징
        - 반복적인 읽기가 많은 호출에 적합
        - 캐시와 DB가 분리되어 가용됨
            - 원하는 데이터만 별도로 구성하여 캐시 저장
            - 캐시 장애 대비 구성이 되어 있음
    - 장점
        - 캐시에 문제가 생기는 경우, DB로 요청을 위임하여 데이터를 가져옴
    - 단점
        - 캐시와 DB의 동기화가 되지 않아 데이터 정합성 유지가 어려움
        - 첫 조회 시 DB 부하 발생 (첫 조회는 DB로부터 데이터를 가져와 캐시에 올려놓고 사용해야함)

<br>

- 쓰기 전략
    - `Write Back 패턴`
    <img src="https://github.com/jmxx219/CS-Study/assets/50795805/67bef250-b17f-4204-9a1c-90f5d964e0d8" width="400" height="200"/>

    - 개념
        - 데이터 저장시 DB에 바로 쿼리하지 않고 캐시에 모아 일정 주기 배치 작업을 통해 DB에 반영
        - 쓰기작업이 많아, Insert쿼리를 일일이 날리지 않고 한꺼번에 배치 처리하기위해 사용
    - 특징
        - 데이터 저장시 DB가 아닌 먼저 캐시에 저장해 모아놨다가 특정 시점 DB에 쓰기에 캐시가 일종의 Queue역할을 겸함
    - 장점
        - DB쓰기 횟수 비용과 부하 줄일 수 있음
        - DB에 장애가 발생하더라도 지속적인 서비스 제공 보장
    - 단점
        - 데이터를 옮기기전 캐시 장애 발생 시 데이터 유실 발생 가능 
        - 자주 사용되지 않는 불필요한 리소스 저장
        - 캐시에서 요류 발생시 데이터 영구 소실

<br>
<br>

### Redis와 Memcached

**공통점**
- In Memory 저장소
- Key-value 저장 방식
- 1ms 이하의 응답 대기 시간
- 데이터 파티셔닝
    - 데이터를 여러 노드에 분산시켜 저장
    - 데이터 효과적 처리를 위한 스케일아웃 가능
- 다양한 프로그래밍 언어 지원

<br>

> **In-Memmory 데이터베이스**
>  데이터 저장을 메모리에 의존하는 특수 데이터베이스로, 디스크에 대한 접근을 없애 최소한의 응답시간을 가지도록 설계

<br>

**Memcached 특징**
- 정적 데이터 캐싱에 효과적
    - metadata에 더 적은 작원을 소모하기 때문에 내부 메모리 관리는 단순한 경우 매우 뛰어남
    - Redis 만큼 정교하지 않으나 String(유일한 지원 데이터 타입)은 추가 처리가 필요없어 읽기 전용에 적합

- 직렬화 데이터 저장
    - Redis
        - 데이터의 모든 형태를 그대로 저장 가능
    - Memcached
        - 직렬화된 형태로 데이터 저장하도록 제한 
        - 직렬화 오버헤드를 보다 줄일 수 있음

- 멀티 쓰레드 기능 지원
    - Redis
        - **단일 쓰레드**로 데이터 손실없이 수평으로 스케일링
    - Memcached
        - **멀리 쓰레드**로 Redis에 비해 스케일링 유리
        - 컴퓨팅 자원 추가로 스케일 업 가능
        - 캐시된 데이터 유실 확률도 높음

<br>
<br>

### Memcached가 아닌 Redis 사용 이유
- 다양한 자료 구조 및 용량 지원
    - Memcached
        - key 이름 250 byte까지 제한
        - 단순히 string만 지원
    - Redis
        - keys, value 이름 512mb까지 지원
        -  hash, set, list, string 등 다양한 데이터 구조 지원

- 다양한 삭제 정책 지원 (캐시 데이터 공간 확보 방법)
    - Memcached
        - LRU 방식 사용
        - 새로운 데이터와 크기가 비슷한 데이터 임의 제거
    - Redis
        - 6가지의 다른 데이터 삭제 정책 제공
        - 메모리 관리와 데이터 삭제 선택에 더 정교한 접근법 제공
        - lazy, active 삭제 지원

- 디스크 영속화 지원
    - Memcached와 달리 디스크 영구 저장 가능
    - DB의 데이터들은 서버 충돌이나 재부팅 시에도 복구 가능

- 복제 지원 
    - 복제를 통해 데이터의 복제본이 또다른 인스턴스에 유지
    - Memcached는 Third Party를 사용하지 않고서는 복제본을 가질 수 없음

- 트랜젝션 지원
    - Memcached
        - 원자적으로 동작하나 트랜잭션을 지원하지 않음
    - Redis
        - 명령 실행을 위한 트랜잭션을 지원

<br>
<br>

### Ref
[레디스 소개 & 사용처 (캐시 / 세션) - 한눈에 쏙 정리](https://inpa.tistory.com/entry/REDIS-📚-개념-소개-사용처-캐시-세션-한눈에-쏙-정리?category=918728#)               
[우아한 Redis 정리(1)](https://codediary21.tistory.com/103)
[In-memory Redis vs Memcached 비교하기](https://escapefromcoding.tistory.com/704)
