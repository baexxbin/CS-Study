## HTTP란?

: HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 프로토콜

- 웹에서 이뤄지는 모든 데이터 교환의 기초
- 통신 : TCP/IP를 통해 이뤄짐
- ‘**클라이언트 - 서버 프로토콜**’
    
    : 수신자 측(ex 웹 브라우저)에 의해 요청이 초기화되는 프로토콜 
    
    - 클라이언트와 서버는 개별적인 메시지 교환에 의해 통신
    - 요청(requests) : 클라이언트에 의해 전송되는 메시지
        - 클라이언트는 하나의 객체, 사용자 에이전트, 프록시등이 될 수 있음
        - 대부분의 경우 사용자 에이전트는 브라우저 임
    - 응답(responses) : 요청에 대해 서버에서 응답으로 전송되는 메시지

- 특징
    - 간단함
        - HTTP 메시지 사람이 읽을 수 있음 (HTTP/2 이전)
        - HTTP 메시지를 프레임별로 캡슐화해 간결함 유지 (HTTP/2)
    - **확장 가능한 프로토콜**
        - HTTP헤더를 통해 언제든지 새로운 기능 추가 가능
    - 상태는 없지만 세션은 있음
        - HTTP는 상태를 저장하지 않음(stateless)
        - 하지만 쿠키를 통해 상태가 있는 세션을 만들도록 함
    - 어플리케이션 계층의 프로토콜
        - 이론상 신뢰 가능한 전송 프로토콜이란면 무엇이든 사용 가능
        - 실제로는 TCP 혹은 TLS(암호화된 TCP 연결)를 통한 전송

- 약점
    - 암호화 되지 않은 평문 통신으로 도청 가능
    - 통신하려는 상대를 확인하지 않음

<br>

### **HTTP의 흐름**

1. **TCP 연결 열기**
    1. 클라이언트는 새 연결 열기, 기존 열결 재사용, 서버에 대한 여러 TCP연결을 열 수 있음
    
<br>

2. **HTTP 메시지 전송 (요청)**
    
    ```jsx
    GET / HTTP/1.1
    Host: developer.mozilla.org
    Accept-Language: fr
    ```
    
    요청의 구성
    
    - Method : `GET`
        - 클라이언트가 수행하고자 하는 동작
    - Path : `/`
        - 가져오려는 리소스의 경로
    - Version of the protocal : `HTTP/1.1`
        - HTTP 프로토콜의 버전
    - Headers
        
        `Host: developer.mozilla.org
        Accept-Language: fr` 
        
        - 서버에 대한 추가 정보 전달하는 선택적 헤더들
    
<br>

3. **서버에 의해 전송된 응답 읽기**
    
    ```jsx
    HTTP/1.1 200 OK
    Date: Sat, 09 Oct 2010 14:28:02 GMT
    Server: Apache
    Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
    ETag: "51142bc1-7449-479b075b2891b"
    Accept-Ranges: bytes
    Content-Length: 29769
    Content-Type: text/html
    
    <!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
    ```
    
    응답의 구성
    
    - Version of the protocol : `HTTP/1.1`
        - HTTP 프로토콜의 버전
    - Status code : `200`
        - 요청의 성공 여부과 그 이유를 나타내는 상태코드
    - Status message : `OK`
        - 상태코드의 짧은 설명을 나타내는 상태 메시지
    - Headers : `Date: 부터 끝까지`

<br>


4. **연결 닫기 혹은 다른 요청들을 위한 재사용**

<br>


## 대칭 키 암호화와 비대칭 키 암호화
<br>

**공개 키 : 누구든지 키를 확인할 수 있고 사용할 수 있도록 대중에게 공개된 키**

**개인 키 : 자기자신만이 관리하고 가지고 있는 키**

<br>

### [ 대칭 키 암호화 ]

똑같은 개인 키를 송・수신자가 공유하여 정보를 암호화・복호화 하는 것

**대칭 키 : 어떤 정보를 암호화・복호화 할 때 사용하는 키가 동일한 경우**

- 암호화 된 정보의 전달, 확인을 위해선 송・수신자 둘 다 같은 키를 가져야 함
    - 어떤 정보가 대칭 키를 통해 암호화 되었을 시, 똑같은 키를 갖고 있는 사용자가 아닐 경우 해당 정보 확인 불가
- 키의 안전한 교환이 대칭 키 암호화 방식의 가장 중요한 부분

- 장점
    - 암・복호화 과정이 단순
    - 암・복호화 과정의 속도가 빠름
        
        ⇒ 송신자와 수신자가 동일한 키를 가지고 있기 때문
        
- 단점
    - 송・수신자 간 키 교환이 이뤄져야함
    - 키 교환 과정 중 키 노출 위험
    - 송・수신자가 늘어날수록 관리해야할 키의 증가로 관리의 어려움

<br>
<br>

### [ 비대칭 키 암호화 ]

: 공개 키와 개인 키 한 쌍(키 페어)로 각각 암호화・복호화에 적용하여 암호화・복호화 하는 것

**비대칭 키 : 어떤 정보를 암호화・복호화 할 때 사용하는 키가 서로 다른 경우**

- 암호화 시 사용하는 키
    - 개인 키
    - 공개 키
- 암호화 방식
    - 개인 키 암호화 방식
        
        : 자신의 개인 키를 통한 암호화, 자신의 공개 키를 통한 복호화
        
        - 정보의 내용보다 정보를 암호화한 주체에 대해 초점을 둔 방법
        - 정보를 생산(송신)한 사람의 신원 정보 필요 시 사용
        - 데이터 제공자의 신원이 보장되는 ‘전자서명’ 등의 공인인증체계의 기본
    - 공개 키 암호화 방식
        
        : 상대방의 공개키를 통한 암호화, 상대방의 개인 키를 통한 복호화
        
        - 정보 자체에 대한 암호화가 필요 시 사용
        - 공개 키로 암호화시 개인 키로 해제 가능 (공개 키로 해제 불가능)
        - 대칭 키 암호화 방식에서 키 값 교환에 따른 문제를 해결한 방법

- 장점
    - 단 하나의 공개 키를 사용함으로 모든 수신자와 개별 키를 만들 필요 없음
    - 데이터 송신과정 중 키를 탈취 당하더라도 해당 키로 복호화가 불가능하기에 공개키 방식보다 안전
- 단점
    - 암・복호화에 서로 다른 키를 사용하므로 대칭키와 비교해 느린 속도

<br>

## 왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?

<br>

**HTTPS : HTTP 프로토콜의 보안버전**

- HTTPS는  HTTP(응용계층 프로토콜)와 TCP(전송 계층 프로토콜) 사이에 SSL/TLS 프로토콜을 거치도록 설계
- 데이터 전송, 수신 시
    - (HTTP/TCP)가 SSL에게 데이터 전송 시 SSL이 데이터를 (암호화/복호화)하여 (TCP/HTTP)에게 전달
- 안전한 데이터의 전달이 브라우저와 웹 서버 사이 전달 구간에서 이뤄짐
    - 보안채널, 전송 보안이라고도 불림
- HTTPS 통신

    대칭키 방식과 공개키 방식 함께 사용
    
    - 대칭키 방식
        - 실제 데이터 암호화 시 사용
    - 공개키 방식
        - 서버에 대한 인증과 안전한 대칭키 전달 시 사용

<br>


**SSL/TLS : 컴퓨터 네트워크 상에서 보안 통신을 제공하기 위해 설계된 프로토콜**

- TLS는 SSL의 취약점들을 개선한 다음 버전의 프로토콜
- 특정 네트워크 계층에 속하는 프로토콜이 아닌, 독자적으로 존재하는 프로토콜
    - 응용계층과 전송계층 사이에 위치하여 보안과정 수행 

<br>



**SSL/TLS 인증서**
: SSL/TLS 기술을 수행하기 위해 웹 서버에 설치하는 것

- CA에서 검증된 서버에 대해 발급한 인증서
- SSL 인증서에는 주로 서버의 공개키가 들어가 있으며, 이는 나중에 데이터 교환을 위한 대칭키 전달에 사용
- 탑재된 보안기술
    - 대칭키/비대칭키 암호화 방식
    - 통신 대상을 서로가 확인하는 신분확인
    - 믿을 수 있는 SSL 인증서를 위한 디지털 서명 및 인증기관의 확인
    - 안전한 공개키 전달,공유를 위한 프로토콜
    - 암호화된 메시지의 변조 여부 확인하는 메시지 무결성 알고리즘

<br>


### **SSL Handshake (TLS Handshake)**

**: 송신자와 수신자가 암호화된 데이터를 교환하기 위한 일련의 협상과정**

*협상과정에는 SSL 인증서 전단, 대칭 키(비밀 키)전달, 암호화 알고리즘 결정, SSL/TLS 프로토콜 결정 포함

### **SSL 핸드셰이크 과정**

: 브라우저와 웹 서버가 서로 암호화 통신을 시작할 수 있도록 신분을 확인하고, 필요정보를 주고받는 과정

**클라이언트: (1) 클라이언트에 해당하는 브라우저의 웹 서버 접속 [Client Hello]**

- Client Hello 단계에서 브라우저가 보내는 정보
    - 브라우저가 사용하는 SSL/TLS 버전 정보
    - 브라우저가 지원하는 암호화 방식 모음(cipher suite)
        - 아래 내용을 패키지 형태로 묶어놓은 것
            - 안전한 키 교환, 전달 대상 인증, 암호화 알고리즘, 메시지 무결성 확인 알고리즘 방식
    - 브라우저가 순간적으로 생성한 임의의 난수
    - 이전에 SSL핸드셰이크가 완료된 상태일 경우, 그때 생성된 세션 아이디

<br>


**서버: (2) 웹 서버는 (1)번에 응답하며 다음정보를 클라이언트에 제공 [Server Hello]**

- 브라우저의 암호화 방식 정보 중 서버가 지원하고 선택한 암호화 방식
- 서버의 공개캐가 담긴 SSL 인증서
- 서버가 순간적으로 생성한 임의의 난수
- 클라이언트 인증서 요청(선택사항)

<br>

**클라이언트: (3) 브라우저는 서버의 SSL 인증서가 올바른지 확인**

- 내장된 CA 공개키로 암호화된 인증서 복호화
    - 서버가 보낸 SSL인증서가 CA 발급인지 확인
    - 정상적 복호화 → CA발급 증명
    - 등록된 CA 아님 or 가짜 인증서 → 브라우저에게 경고 보냄

<br>

**클라이언트: (4) 브라우저는 자신이 생성한 난수와 서버의 난수를 사용해 premaster secret 생성**

- 웹 서버 인증서에 딸려온 웹 사이트의 공개키로 premaster secret을 암호화해 서버로 전송

<br>

**서버: (5) 서버는 사이트의 비밀키로 브라우저가 보낸 premaster secret 값 복호화**

- 복호화한 값을 master secret 값으로 저장
- master secret을 사용해 브라우저와 만들어진 연결에 고유한 값을 부여하기 위한 세션 키 생성
    - 세션키
        - 대칭키 암호화에 사용하는 키
        - 브라우저와 서버 사이 주고받는 데이터 암호화, 복호화

<br>

**서버/클라이언트: (6) SSL 핸드셰이크를 종료하고 HTTPS 통신 시작**

- 브라우저와 서버 SSL핸드셰이크 정상적 완료
- 세션키를 통해 웹 상의 데이터 암/복호화하며 HTTPS 프로토콜을 통해 주고 받음
- HTTPS 통신 완료 시점에 서로에게 공유된 세션키 폐기
- SSL핸드셰이크 단계까지는 공개키 방식 사용
- 이 후 HTTPS 통신은 대칭키 방식 사용

<br>

## SSL과 TLS의 차이는 무엇인가요?
<br>

**TLS**

- SSL의 후속 버전으로 개발 됨
- 여전히 SSL용어를 통해 TLS를 지칭하기도 함
- 대부분 SSL과 호환 됨

<br>

**SSL(Secure Socket Layer) / TLS(Transport Layer Security)**

- 공통점
    - 보안 프로토콜로서, 통신을 암호화하고 안전하게 만드는 목적
- 차이점
    - 보안 강화
        - SSL 3.0의 Poodle과 같은 보안 취약점 개선
    - 보다 강력한 암호화 알고리즘 사용
        - TLS 1.2에서 AES, HMAC알고리즘 사용