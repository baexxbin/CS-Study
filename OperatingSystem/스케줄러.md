### 스케쥴러

- 프로세스를 선택하는 작업.

### Ready Queue

- 레디상태의 프로세스들이 모아져 있음. 스케쥴러는 레디큐에서 어떤 프로세스가 다음에 선택되야 하는지 결정.

### 장기 스케줄러 ( = 작업 스케줄러)

- 어떤 프로세스를 Ready Queue 에 삽일할 지 결정한다. 작업 스케쥴러라고도 불린다. 디스크에서 하나의 프로그램을 가져와 커널에 등록하면 프로세스가 되는데 이 때 디스크에서 어떤 프로그램을 가져와 커널에 등록할지(Ready Queue에 등록할지) 결정한다
- 장기 스케줄러는 메모리에 동시에 올라가 있는 프로세스의 수를 조절 하는 역할도 한다.
- 장기 스케줄러는 수십 초 ~ 수 분  단위로 호출이 적기에 상대적으로 속도가 느린 것이 허용된다.
- 하지만, 현대의 시분할 시스템에서 사용되는 운영 체제는 일반적으로 장기 스케줄러를 두지 않는 경우가 대부분이다. 현대의 운영체제는 프로세스가 시작되면 장기 스케줄러 없이 바로 그 프로세스에 메모리를 할당해 Ready Queue에 넣어준다.

### 중기 스케줄러 ( = Swapper)

- 메모리에 적재된 프로세스의 수를 동적으로 조절하기 위해 추가된 스케줄러.
- 프로세스 메모리를 관리하고 주 메모리(RAM)와 보조 스토리지(디스크) 간의 프로세스 스와핑을 처리
- 시스템이 메모리 정체를 경험하거나 프로세스가 오랜 기간 동안 유휴 상태일 때 중기 스케줄러는 다른 프로세스를 위한 공간을 확보하기 위해 메모리에서 프로세스를 교체하도록 결정한다.
- 반대로 프로세스를 재개해야 할 때 보조 스토리지에서 메모리로 프로세스를 스왑할 수도 있다.

### 단기 스케줄러 ( = CPU 스케줄러)

- 단기 스케줄러는 Ready Queue에서 다음에 실행할 프로세스를 선택하고 CPU 시간을 할당하는 일을 담당.
- 주요 목표는 프로세스가 대기하는 시간을 최소화하고 전체 시스템 성능을 최대화하여 효율적인 CPU 활용을 보장하는 것
- 이 스케줄러는 일반적으로 밀리초 또는 마이크로초 단위로 자주 호출되어 프로세스 실행에 관 한 결정을 신속하게 내린다.

## Q) 현대 OS에는 단기, 중기, 장기 스케쥴러를 모두 사용하고 있나요?

- 최신 운영 체제와 관련하여 단기 스케줄러는 실행할 다음 프로세스 결정을 담당하므로 보편적으로 사용한다.
- 그러나 중기 스케줄러와 장기 스케줄러의 포함 여부는 다르다.
- 일부 운영 체제에는 별도의 중기 스케줄러가 없을 수 있으며 대신 단기 또는 장기 스케줄링 메커니즘 내에서만 스와핑 및 프로세스 메모리를 처리한다.
- 마찬가지로 장기 스케줄러는 프로세스가 더 엄격하게 제어되는 시분할 시스템에서는 없는 경우가 일반적이다.

## Q) 프로세스의 스케쥴링 상태에 대해 설명해 주세요.

프로세스는 다음 5가지 상태 중 하나를 가진다.

- New : 프로세스가 생성된 상태이며, 운영체제가 아직 할당되지 않은 자원을 가지고 있다.
- Ready : 프로세스가 실행을 기다리는 상태이며, 운영체제가 필요한 자원을 할당하여 실행 가능한 상태.
- Running : 프로세스가 CPU를 사용하여 실행되는 상태이며, CPU 시간을 할당 받아 작업을 수행한다.
- Blocked : 프로세스가 실행을 중지하고, 특정 이벤트가 발생하기를 기다리는 상태. 이벤트는 주로 입출력(IO) 작업과 같은 외부 요청이다.
- Terminated : 프로세스가 완전히 종료되어 더 이상 실행되지 않는 상태.

## Q) preemptive/non-preemptive 에서 존재할 수 없는 상태가 있을까요?

### preemptive

- 현재 실행중인 프로세스를 중단시키고 다른 프로세스가 CPU를 점유할 수 있도록 하는 방식

### 단점

- 우선 순위가 높은 프로세스를 빠르게 처리할 수 있지만 상황에 따라 잦은 컨텍스트 스위칭으로 오버헤드가 발생할 수 있다.

ex) SRTF,RR,스케줄링 우선순위(Scheduling Priority(priority = 다음 cpu burst time을 예))

### non-preemptive

- 현재 프로세스가 작업을 종료하고 CPU를 반환할때까지 다른 프로세스가 CPU를 점유할 수 없는 방식

### 단점

- Burst time이 긴 프로세스가 종료될때까지 다른 프로세스들이 대기해야 되기 때문에 처리율이 떨어질 수 있고 우선 순위가 높은 프로세스가 대기해야 되는 문제점이 있다.

ex) SJF,MLFQ와 FCFS,최대 우선순위 처리(Highest Priority First)

### preemptive/non-preemptive 에서 존재할 수 없는 상태가 있을까요?

- 존재한다. 예를 들어 블록 상태가 있다. 블록 상태는 작업 실행이 불가능한 상태로, 작업이 사전 정의된 다른 작업이 완료될 때까지 수행이 중지되는 상태다. 따라서 블록 상태는 preemptive 및 non-preemptive 스케줄링 모두에 존재할 수 없다.

## Q) Memory가 부족할 경우, Process는 어떠한 상태로 변화할까요?

- 프로세스를 수용하기에 메모리가 충분하지 않으면 충분한 메모리를 사용할 수 있을 때까지 차단/대기 상태로 이동할 수 있다.
- 이 경우 프로세스는 메모리 할당을 기다리고 프로세스 상태 전환은 특정 운영 체제의 메모리 관리 정책 및 메커니즘에 따라 달라진다.
- 충분한 메모리를 사용할 수 있게 되면 프로세스가 다시 준비 상태로 전환되고 실행을 재개할 수 있다.
