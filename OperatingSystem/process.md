# 프로세스

<br/>

: 실행을 위해 시스템(커널)에 등록된 작업

- 시스템 성능향상을 위해 커널에 의해 관리 됨
- 프로그램이 메모리로 적재되면 프로세스가 됨
- 각종 자원들을 요청하고 할당 받을 수 있는 개체
- PCB(프로세스 관리 블록)을 할당 받은 개체
- 능동적인 개체 (실행 중 각종 자원을 요구, 할당, 반납함)

<br/>
<br/>

## 프로그램과 스레드

### 프로그램(Program)

: 실행할 작업이 컴퓨터 시스템에 실행 요청 전의 상태

- 실행가능한 코드의 집합
- 디스크 보관, 정적인 상태

<br/>

### 스레드(Thread)

: 프로세서 활용의 기본 단위, 프로세스 내 동작되는 여러 실행의 흐름

- 제어 요소만 가지며 자원(코드, 데이터, 힙)은 프로세스 내 다른 스레드와 공유
- 프로세스 내에서 프로세스의 자원을 이용해 실제 작업을 수행
- 각 스레드는 독자적인 스택 메모리를 가짐

<br/>

**스레드의 장점**

- 사용자 응답성
    - 일부 스레드의 처리가 지연되어도 다른 스레드는 작업 계속 처리 가능
- 자원 공유
    - 자원을 공유해 효율성 증가 (커널의 개입을 피할 수 있음)
- 경제성
    - 프로세스의 생성, context switch에 비해 효율적
- 멀티 프로세서 활용
    - 병렬처리를 통해 성능 향상

 <br/>
 
**프로그램 vs 프로세스**
- 파일이 저장 장치에 있지만 메모리에는 올라가 있지 않은 상태 -> 프로그램
- 프로그램을 실행 후 메모리에 올라가 있는 상태 -> 프로세스

<br/>

**프로세스 vs 스레드**
- 프로그램이 복잡해져서 프로세스 하나만으로 실행하기 어렵다.
- 운영체제는 안정성을 위해서 프로세스마다 할당된 메모리 내의 정보에만 접근할 수 있도록 제약
- 따라서 프로세스를 여러 개 만들 수 없음, 더 작은 실행 단위 개념 필요 -> 스레드
- 프로세스와 다르게 스레드는 서로 메모리를 공유하며 작동

<br/>

**프로그램 VS 프로세스 VS 스레드** 

|  | 프로그램 | 프로세스 | 스레드 |
| --- | --- | --- | --- |
| 정의 | 실행 가능한 코드의 집합 | 실행 중인 프로그램 인스턴스 | 프로세스 내 실행 단위 |
| 실행 단위 | - | 단일 프로세스 | 프로세스 내 스레드 |
| 독립성 | - | 각각 독립적 | 스택(제어)만 독립 |
| 자원 공유 | - | 다른 프로세스와 공유X | 다른 스레드와 공유 |
| 스케줄링 | - | 운영체제에 의해 스케줄링 | 프로세스 내 스레드 스케줄링 |

<br/>
<br/>

## PCB(Process Control Block)

: 프로세스 관리 블록으로, OS가 프로세스 관리에 필요한 정보를 저장한 구조체

- 프로세서 생성 시 커널에 PCB 생성
- 프로세스의 상태관리와 Contex Switching을 위해 필요
- PCB 저장 정보
  - `프로세스 상태`: 생성, 준비, 수행, 대기, 중지
  - `프로세스 번호(PID)`
  - `프로그램 카운터`
  - `레지스터`
  - `메모리 제한`
  - `열린 파일 정보`

<br/>

### TCB(Thread Control Block)

: 스레드의 상태와 관련된 정보를 저장하는 데이터 구조로, 스레드는 PCB를 가지지 않고 TCB를 가짐

- 스레드의 고유 식자, 레지스터 값, 스택 포인터, 스케줄링 정보 포함
- 스레드는 동일한 프로세스 내에서 실행되므로 프로세스의 PCB와 관련된 리소스를 공유
    - 여러 스레드가 하나의 PCB를 공유하며, 각 스레드는 자체 TCB를 가지고 자신의 상태 관리

<br/>
<br/>

## 프로세스와 스레드 생성

### 프로세스 생성

- fork()
    
    : 기존의 프로세스를 복제하여 새로운 프로세스 생성
    
    - 새로운 프로세스는 부모 프로세스의 복제본
        - 부모의 PCB도 함께 복사
    - Binary program을 읽어서 자신을 호출한 process의 메모리 영역에 덮어씀
    - 부모와 자식 프로세스는 동시에 수행되나 독립적으로 실행
    - 새로운 프로세스를 위한 메모리 할당
- exec()
    
    : 새로운 프로세스로 프로세스의 실행 내용 **교체**
    
    - 새로운 프로세스을 현재 프로세스의 주소 공간에 로드하고 실행하는데 사용
    - 기존의 프로세스를 새로운 프로세스로 전환
    - fork()처럼 새로운 메모리 할당X
    - 부모 프로세스 내용 복사X

<br/>

### 스레드 생성

- pthread_create()
    
    : POSIX 스레드 라이브러리를 사용해 스레드 생성
    
    - 새로운 스레드 생성 & 스레드 실행 시작
    - 부모 프로세스의 주소공간 공유
    - 프로세스 내 병렬적 실행
- clone()
    
    : 리눅스 커널의 clone() 시스템 호출을 사용해 스레드 생성
    
    - fork()와 비슷하나 추가적인 플래그를 통해 스레드 생성 가능
    - 부모와 자식간의 리소스 공유

<br/>
<br/>

## 좀비 프로세스와 고아 프로세스

### **일반적인 프로세스의 종료**

: 프로세스 종료 시 ‘어떻게 종료되었는지’를 exite status에 저장
* 정상종료
    * 프로세스가 작업을 완료하고 더 이상 실행할 작업이 없는 경우
    * 프로세스는 종료 코드(Exit Code)를 반환하며 운영 체제에 종료 신호 보냄  

* 명시적인 종료 요청
    * 시그널을 통해 운영 체제 또는 외부 요인으로부터 종료를 요청 받음  
    * 시그널 처리 후 종료작업 수행

* 다른 프로세스에 의한 종료
    * 부모 프로세스가 자식 프로세스의 종료를 기다릴 때, 자식 프로세스가 종료되면 종료
    * 프로세스 간 통신(IPC) 기법인 프로세스간 파이프, 소켓 등을 사용해 구현

* 시스템 종료
    * 운영 체제가 종료되거나 재부팅되는 경우, 실행 중인 모든 프로세스는 종료
    * 운영 체제에서 제공하는 종료 시그널 또는 시스템 호출을 통해 이뤄짐

- 일반적으로 0은 정상종료를 나타냄
- 자식 프로세스의 종료 상태를 부모 프로세스에게 전달

<br/>

> **wait()**
>
> - 부모 프로세스가 자식 프로세스의 종료상태를 얻기 위해 사용
> - 부모 프로세스는 wait()함수를 사용해 자식 프로세스가 종료될 때까지 기다림

<br/>

### **좀비 프로세스 (Zombie Process)**

: 실행을 완료했으나 죽지 않고 계속 프로세스 테이블에 남아 있는 프로세스

- 자식 프로세스가 종료가 되었지만 부모 프로세스가 아직 wait() 호출을 하지 않은 프로세스
- 종료된 프로세스의 상태를 수집하지 않는 부모 프로세스가 있을 때 발생
- 시스템 리소스를 차지하지만 실행 코드는 없음
    - 일반적으로 시스템에 문제를 일으키지는 않음
- 부모 프로세스보다 먼저 종료된 경우, zombie state가 됨
    - 자원 등은 모두 반납된 상태이나, 커널에 최소한의 정보(exit status, PID)가 남은 상태
    
    ⇒ 부모 프로세스가 시스템 콜을 호출해 exit status를 얻어갈 때가지 좀비 프로세스로 남아있음
    
<br/>

### **고아 프로세스 (Orphan Process)**

: 부모 프로세스가 자식 프로세스보다 먼저 종료되는 경우

-  부모 프로세스가 wait()을 호출하는 대신에 그냥 종료를 해버리는 것

- OS에서 고아프로세스 방지를 위한 방법 
1. 부모 프로세스가 먼저 종료되면, 커널은 자식 프로세스의 새로운 부모 프로세스로 init(PID=1)설정
2. 자식 프로세스가 종료될 때까지 기다리며 그 후에 wait()를 호출하여 종료 상태를 얻음


- 고아 프로세스는 시스템의 자원을 낭비할 수 있고, 시스템이 프로세스가 종료될때까지 추적을 해야해 성능저하의 원인이 됨

<br/>

**자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽는 경우 처리 과정**

- 시그널 처리
    - 일반적으로 시그널을 사용해 자식 프로세스의 종료를 감지하고 처리한다.
- wait()함수로 자식 프로세스 감시
    - wait()함수를 사용해 자식 프로세스가 종료 될때까지 대기하고 상태 확인
- 리소스 관리
    - 부모 프로세스 종료 시 OS는 시그널을 보내 자식 프로세스 종료
    - 자식 프로세스가 고아프로세스로 남아 시스템 리소스 소비 방지

<br/>
<br/>

## 데몬프로세스

데몬 프로세스(Daemon process)

: 백그라운드에서 실행되는 프로세스

- 주로 시스템 서비스나 백엔드 작업 수행
- 사용자의 로그인 세션과 관련 없이 시스템 전반에서 동작
- 일반적으로 웹사이트 서버 가동, 네트워크 서비스, 스케줄러 실행과 같은 장기 작업에 사용
- 시스템의 안정성과 지속적인 서비스 제공을 위한 역할 수행

<br/>

#### 특징
- 백그라운드 실행
    - 백그라운드에서 실행되며 사용자 인터페이스를 가지지 않음
    - 사용자가 로그인 세션을 종료해도 계속 실행
- 자동 시작 및 종료
    - 시스템 부팅 시 자동으로 시작, 시스템 종료 시 안전하게 종료
    - 지속적인 서비스 제공과 시스템 안정성 유지
- 리소스 관리
    - 시스템 리소스에 접근해 서비스 제공
- 로그 기록
    - 시스템 이벤트, 오류, 상태 정보등을 로그 파일에 기록해 모니터링 및 디버깅에 활용
 
<br/>
<br/>
