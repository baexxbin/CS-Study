## Thread Safe

### 스레드 안전 (Thread Satety)
- 개념
    - **멀티 스레드 프로그래밍 환경**에서 적용 가능한 개념 

    - 어떤 함수나 변수, 혹은 객체가 여러 스레드로부터 동시에 접근이 이뤄져도 프로그램의 실행에 문제가 없는 것

    - 두 개 이상의 스레드가 race condition에 들어가거나 같은 객체에 동시에 접근해도 연산 결과는 정합성이 보장될 수 있도록 메모리 가시성이 확보된 상태

    - 스레드에 안전한 코드를 작성하는 것은 근본적으로 여러 스레드에서 공유되는 객체나 클래스의 상태에 대한 접근을 관리하는 것 


    <br>

    > **경쟁 상태 (race condition)**                
    두 개 이상의 프로세스가 공통 자원을 병행적으로 읽거나 쓰는 동작을 할 때, **공용 데이터에 대한 접근이 어떤 순서에 따라 이뤄졌는지에 따라 그 실행 결과가 달라지는 상황**

    <br>

    > **메모리 가시성 (Memory Visiblity)**              
    Thread에서 변경한 특정 메모리 값이 다른 Thread에서 제대로 읽어지는 지.
    > - 스레드들이 하나의 변수를 공유할 경우, 각각의 프로세서 캐시가 변수의 복사본 소유
    > - 여러 스레드에 의해 캐시의 공유 변수 값이 변경되고 캐시 불일치 문제 발생할 수 있음
    > - 스레드가 동일 변수를 다른 값으로 바라보는 문제 발생 가능


<br>
<br>

### 임계영역 (Critical Section)       
- 공유 데이터를 접근하는 코드 영역

<br>

**임계 영역 문제 해결을 위한 필요조건**            
- 상호배제 (Mutual exclustion)              
    - 임계영역에 프로세스가 있으면, 다른 프로세스의 진입을 금지
- 진행 (Progress)               
    - 임계영역 안에 있는 프로세스 외에는 다른 프로세스가 임계영역에 진입하는 것을 방해하면 안됨
- 한정대기 (Bounded waiting)                
    - 프로세스의 임계영역 진입은 유한시간 내에 허용되어야 함

<br>
<br>

### Thread Safe를 지키기 위한 방법

**1. Re-entrancy (재진입성)**
- 스레드 호출과 상관없이 프로그램에 문제가 없도록 작성하는 방법

<br>

**2. Thread-local storage (쓰레드 지역 저장소)**
- 공유 자원의 사용을 최대한 줄이고, 각각의 스레드에서만 접근 가능한 저장소들을 사용함으로써 동시 접근을 막음
- 일반적으로 공유 상태를 피할 수 없을 경우 사용

<br>

**3. Atomic operation (원자 연산)**
- 공유자원에 원자적으로 접근하는 방법
- Atomic
    - 공유 자원 변경에 필요한 연산을 원자적으로 분리
    - 실제 데이터 변경이 이뤄지는 시점에 Lock 걸기
    - 데이터 변경 시간동안 다른 스레드의 접근 막기

<br>

**4. Mutual exclusion (상호 배제)**
- 공유자원 또는 임계영역에 하나의 스레드만 접근할 수 있도록, 세마포어/뮤텍스로 락을 통제하는 방법
    - 일반적으로 많이 사용하는 방법

- primitives
    - Mutual exclusion을 구성하는 기본 연산
    - enterCS() : 임계영역 집입 전 검사 및 다른 프로세서 존재여부 검사
    - exitCS() : 임계영역 벗어날 시 후처리 과정 및 임계영역 벗어남을 알림

<br>
<br>

**Mutual Exclusion Solutions**

- SW solutions 
    - 대표 알고리즘
        - `Dekker's Algorithm`                
            - 프로세스 2개일때 상호배제를 보장하는 최초의 알고리즘
        - `Peterson's Algorithm`              
            - Dekker's Algorithm의 업데이트 버전으로 보다 간단하게 구현             
            - 스레드의 순서를 결정하는 turn 변수를 추가한 알고리즘
        - `Dijkstra's Algorithm`          
            - 최초로 프로세스 n개의 상호배제 문제를 소프트웨어적으로 해결
    - 문제점
        - 느린 속도와 복잡한 구현
        - Busy waiting

<br>

- HW solution
    - `TestAndSet (TAS) instruction`
        - Test와 Set을 한 번에 수행하는 기계어
        - 실행 중 인터럽트를 받지 않음 (기계어로 보장)
        - 구현이 간단하나 여전히 Busy waiting 발생

<br>

- OS supported SW solution
    - `spinlock`
        - 락을 획득하려는 스레드가 락을 얻을 때까지 계속해서 반복하는 방식
        - 정수형 변수이며 OS가 보장
        - 임계영역의 크기가 작은 경우, 멀티코어 환경, 락의 획득 시간이 짧을 경우 효과적
        - 여전한 Busy waiting 문제와 기다리는 동안 CPU리소스 낭비
    - `세마포어`
        - Busy waiting 문제 해결
        - 상호배제, 프로세스 동기화등 다양한 동기화 문제 해결 가능
    - `Eventcount/sequencer`
        - 스레드나 프로세스 간의 통신과 순서를 관리하기 위해 사용
        - Event Count (이벤트 카운트)
            - 어떤 이벤트가 발생했음을 나타내는 카운터로 이벤트 발생시 마다 카운터 증가
            - 다른 스레드나 프로세스는 이벤트 카운터의 값 체크로 원하는 이벤트 발생 확인 및 대기
        - Sequencer (시퀀서)
            - 각 작업에 고유한 번호나 시퀀스를 부여해 작업들이 시퀀스에 따라 순서대로 실행될 수 있도록 보장
        - Busy waiting 문제 해결
        - 세마포어보다 더 low-level 컨트롤 가능

<br>

- Language-Level solution
    - `Monitor`
        - 락과 조건 변수를 사용해 스레드간 상호배제와 협력 간단하게 관리
        - 모니터 내에는 항상 하나의 프로세스만 진입 가능 (언어 보장)
        - 공유 데이터는 모니터 내의 프로세스만 접근 가능
        - 대부분의 프로그래밍 언어와 운영체제에서 모니터 개념 지원
            - Java : synchronized 키워드, wait()/notify() 메서드

<br>

> 위의 `Mutual Exclusion Solutions` 내용들은 Thread Satety만이 아닌 프로세스의 동기화와 상호배제에 대한 전체적인 내용을 포함한다.

<br>
<br>

### 락 (Lock)
- Lock의 필요성
    - `프로세스`는 서로 독립적인 메모리 주소 공간을 부여받음
        - shared memory 경우가 아닌이상 같은 데이터에 동시에 접근할 일 없음
    - `스레드`의 경우 부모 프로세스의 메모리 공간을 공유함
        - 여러 스레드들이 같은 데이터에 접근할 경우 문제 발생
    - 이와 같이 동기화시 공유 자원에 대한 관리 필요

- 개념
    - 병렬 프로그래밍에서 동기화를 달성하기 위한 도구
    - 여러 스레드의 공유 자원 동시접근 제한
    - 스레드의 실행순서 조절로 데이터의 일관성과 안정성 보장
    - 락은 크게 [뮤텍스와 세마포어](https://github.com/jmxx219/CS-Study/blob/main/OperatingSystem/뮤텍스와%20세마포어.md)로 나뉨


<br>
<br>

### Non-Blocking 알고리즘과 Lock Free 알고리즘

**Non-Blocking 알고리즘**             
- 개념 
    - 하나의 스레드가 블록되거나 멈추지 않고도 다른 스레드들이 계속 작업을 수행할 수 있도록 하는 알고리즘

- 구현
    - 일반적으로 원자성(atomicity)과 적절한 동기화 기법을 사용해 이뤄짐
    - 저수준의 하드웨어에서 제공하는 compare-and-swap (CAS연산)등의 명령을 사용하는 알고리즘

- 특징
    - 병렬 컴퓨팅 환경에서 높은 성능과 응답성 제공
    - 데드락 문제 회피 시 유용 
    - 운영체제, JVM 프로세스, 스레드 스케줄링 작업, 가비지 컬렉션 작업, 락이나 기타 병렬 자료 구조를 구현하는 부분에서 사용
    - 구현이 복잡하고 오류 찾기 어려움

<br>

**Lock Free 알고리즘** 
- Non-Blocking 알고리즘에서 각 단계마다 일부 스레드는 항상 작업을 할 수 있는 경우
    
<br>

Lock 기반 알고리즘의 단점
- Lock에 대한 경쟁이 심해질수록, 실제로 필요한 작업을 처리하는 시간 대비 동기화 작업에 필요한 시간이 길어져 성능이 떨어짐

<br>

**CAS 연산**
- 개념
    - 병렬 프로그래밍에서 동기화를 위한 기술로, 여러 스레드가 동시에 공유 변수를 수정하는 상황에 사용
    - 스레드간 경합 조건을 줄이고 동기화 오버헤드를 최소화하는 방식으로 병렬 프로그래밍 지원
    - 일반적으로 원자적 연산을 지원하는 하드웨어에서 지원
    - 이를 기반으로 락이나 뮤텍스보다 경량적인 동기화 메커니즘 구현

- CAS 연산 구조
    - 3개의 인자 사용
    - 대상 메모리 위치(V) : 값을 변경하려는 변수의 주소나 위치
    - 예상 기존 값(A) : 현재 V에 저장된 값과 비교할 값
    - 새로 설정할 값(B) : V에 저장될 새로운 값

- CAS 동작 원리
    - 1. V의 현재 값을 A와 비교
    - 2. V의 값이 A와 같을 경우 V의 값을 B로 변경
    - 3. V의 값이 A와 같지 않을 경우 아무동작하지 않음

- 특징
    - 원자적 연산
        - CAS연산은 단일 연산으로 간주되며, 값을 비교하고 변경하는 동작이 원자적으로 수행
        - 즉, CAS연산이 진행되는 동안 다른 스레드가 V의 값을 변경하지 못함
    - 성공 및 실패 리턴
        - CAS연산 성공 여부와 관계 없이 현재의 V값 리턴
        - CAS연산을 성공한 스레드는 새로운 값을, 실패한 경우 현재값(A와 비교한 값)을 얻음
    - 경쟁조건과 데드락 회피
        - 여러 스레드가 동시에 CAS연산을 시도할 때, 오직 하나의 스레드만 성공하고 나머지 스레드는 실패함
        - 실패한 스레드들은 다시 시도 혹은 다른 처리 방법 선택으로 경쟁 조건 회피
           
<br>
<br>

### Python에서의 Thread Safe
- Python의 GIL
    - Python은 Thread Safe하게 메모리를 관리하지 않기에 GIL을 사용해 Thread Safe를 보장

<br>

> **Python GIL**                
파이썬 코드가 실행될 때 여러개의 스레드 중 하나의 스레드만 실행될 수 있도록 하는 뮤텍스
> - 파이썬은 thread safe하지 않은 garbage collection 메모리 관리 정책 사용
> - 이로 인해 스레드를 직렬로 실행시켜 멀티스레드의 장점을 사용하지 못하는 GIL 사용