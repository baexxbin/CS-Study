## 프로그램 실행 과정

<br>

**코드 작성 -- (컴파일) --> 오브젝트 파일 -- (링킹) --> 실행 파일 -- (로드) --> 메모리 적재 및 수행.**

<br>

**오브젝트 파일(목적 파일, Object File):** 컴파일된 파일, 작성된 코드를 **'컴파일(Compile)'** 과정을 거쳐 컴퓨터가 이해할 수 있는 언어로 변환된 것이다.

컴파일과 어셈블리 과정을 거친 파일로서 0과 1로 이루어져 있다. 컴퓨터 아키텍처에 의존적인 파일이기 때문에 변환한 환경이 달라지는 경우 다시 컴파일과 어셈블리 과정을 거쳐야 한다. 오브젝트 파일만으로는 실행할 수 없으며 링킹 과정을 거쳐야 실행이 가능하다.

**컴파일**: 고급언어(C, JAVA..)로 프로그래밍한 코드를 CPU가 이해할 수 있게 변환해주는 것이다.

**링킹(Linking):** 링킹이란 컴파일 이후, 실행하기 이전에 작성한 프로그램이 사용하는 다른 프로그램이나 라이브러리를 가져와 연결하는 과정을 말한다.

코드를 컴파일 과정과 링킹 과정을 거치면 사용자가 실행할 수 있는 **실행 파일**(ex. EXE파일)이 생성된다.

**로더(Loader):** 완성된 실행파일을 사용자가 실행(Execute)하게 되면 컴퓨터는 해당 프로그램의 내용을 메모리에 적재(Load)시키고 내용에 따라 프로그램을 수행하게 된다. 이러한 일을 수행하는 프로그램


<br/>


## 링커

링킹을 담당하는 프로그램, 독립적인 컴파일을 가능하게 하는 역할

링커는 소프트웨어 개발에서 독립적인 컴파일을 가능하게 하는 아주 중요한 역할을 담당, 링커 덕분에 큰 규모의 운용 프로그램을 한 개의 소스 파일로 구성하는 대신 별도로 수정할 수 있고, 컴파일할 수 있는 보다 관리할 만한 규모의 더 작은 모듈들로 나눌 수 있다. 즉, 아주 거대한 프로그램을 하나의 소스 파일이 아니라 수 많은 소스 파일로 모듈화하여 개발을 진행할 수 있다. 

그래서 모듈 중에 한 개를 변경할  때, 다른 파일들을 재 컴파일할 필요 없이 이 파일만을 간단히 재컴파일하고 이를 다시 링크하여 변경 사항을 적용할 수 있다.

<br/>

## 정적 링킹(****Static Linking)****

**정적 링킹이란 실행 가능한 목적 파일을 만들 때 프로그램에서 사용하는 모든 라이브러리 모듈을 복사**하는 방식을 말하며 링커에 의해 이루어진다. 즉, 자신이 작성한 프로그램에서 A라는 외부 함수를 사용했다면, A라는 외부 함수에 대한 정보를 자신이 작성한 프로그램의 실행파일을 만들 때 복사해온다.

### 장점

1. 동적 링킹보다 상대적으로 빠르다.
2. 불일치에 대한 걱정을 하지 않아도 된다.
    1. 정적 링킹 프로그램에서 모든 코드는 하나의 실행 모듈에 담기기 때문이다.

### 단점

1. 정적 링킹은 중복이 발생할 수도 있어,  프로그램은 크기가 크고 메모리 효율이 좋지 않다.
    1. 만약 여러 개의 프로그램에서 외부 함수를 사용하면, 정적 링킹 방식은 프로그램들의 실행 가능한 목적파일 각각에 외부 함수 정보가 담긴다. 

1. 외부 함수가 변경이 생길 경우 그 변화를 적용하기 위해서 다시 컴파일하여 다시 링킹을 해야 한다.
    1. 실행 가능한 목적파일을 만들 때 A에 관한 정보를 그냥 복사해왔기 때문에 외부 함수에 변화가 생겨도 다시 컴파일하지 않는 이상 적용이 안된다.

<br/>

## 동적 링킹(****Dynamic Linking)****

**동적 링킹이란 실행 가능한 목적 파일을 만들 때 프로그램에서 사용하는 모든 라이브러리 모듈을 복사하지 않고 해당 모듈의 주소만을 가지고 있다**가, 런타임에 실행 파일과 라이브러리가 메모리에 위치될 때 해당 모듈의 주소로 가서 필요한 것을 들고 오는 방식이다. 런타임에 운영체제에 의하여 이루어진다.

### 장점

1. 정적 링킹 방식보다 실행 가능한 목적파일의 크기가 작아, 메모리와 디스크 공간을 아낄수 있다.
    1. 여러 프로그램에서 외부 함수를 이용해도 외부 함수 정보는 하나만 있으면 된다.
    2. 목적파일에서는 외부 함수를 복사하는 것이 아닌 외부 함수가 있는 곳의 주소만 가리키고 있으면 된다.

1. 외부 함수의 변화가 생겨도 변화를 적용하기 위해 다시 컴파일해 다시 링킹할 필요가 없 다.
    1. 목적파일에 외부 함수에 관한 정보를 복사한 것이 아닌 외부 함수의 주소를 담았기 때문 

1. 동적 라이브러리가 이미 존재하는 경우 로드되는 시간을 단축할 수 있다.

### 단점

1. 매번 주소를 따라가야 하는 오버헤드가 존재해, 정적 링킹 방식보다 느리다.
2. 불일치에 대한 문제를 고려해야 한다.
    1. 사용하던 외부 함수가 시스템에서 제거가 된다면, 해당 프로그램의 실행 가능 목적파일에는 외부 함수의 주소가 있어서 존재하는 것처럼 동작을 해 제대로 실행될 수 없다.

<br/>

## 로더

외부기억장치로부터 정보들을 주기억 장치로 옮기기 위하여 메모리 할당 및 연결, 재배치, 적재를 담당하는 서비스 프로그램이다.

로더는 기본적으로 다음과 같은 기능을 차례로 수행하지만, 로더의 각 기능을 언어 번역 프로그램 또는 링커 등의 시스템 소프트웨어가 수행할 수도 있다.

- **할당(Allocation)** : 실행 프로그램을 실행시키기 위해 기억장치 내에 옮겨놓을 공간을 확보하는 기능
- **연결(Linking)** : 부 프로그램 호출 시 그 부 프로그램이 할당된 기억장소의 시작주소를 호출한 부분에 등록하여 연결하는 기능
- **재배치(Relocation)** : 디스크 등의 보조기억장치에 저장된 프로그램이 사용하는 각 주소들을 할당된 기억장소의 실제 주소로 배치시키는 기능
- **적재(Loading)** : 실행 프로그램을 할당된 기억공간에 실제로 옮기는 기능

<br/>

### 로더의 종류

**1) 컴파일 즉시 로더(Compile And Go)**

- 별도의 로더 없이 언어 번역 프로그램이 로더의 기능까지 수행하는 방식이다.
- 연결 기능은 수행하지 않고 할당, 재배치, 적재 작업을 모두 언어 번역 프로그램이 담당한다.

**2) 절대 로더(Absolute Loader)**

- 목적 프로그램을 기억장소에 적재시키는 기능만 수행하는 로더로, 로더 중 가장 간단한 프로그램으로 구성되어 있다.
- 기억장소 할당이나 연결을 프로그래머가 직접 지정하며 한번 지정한 주기억장소의 위치는 변경이 어렵다.

**3) 직접 연결 로더(Direct Linking Loader)**

- 일반적인 기능의 로더로, 로더의 기본 기능 네 가지를 모두 수행하는 로더이다.
- 재배치 로더(Relocation Loader), 상대 로더(Relative Loader)라고도 한다.

**4) 동적 적재 로더(Dynamic Loading Loader)**

- 프로그램을 한꺼번에 적재하는 것이 아니라 실행 시 필요한 부분만을 적재하고 나머지 부분은 보조기억장치에 저장해두는 것으로, 호출 시 적재(Load-On-Call)라고도 한다.
- 프로그램의 크기가 주기억장치의 크기보다 큰 경우에 유리한 방법이다.


<br/>

## 자바 컴파일 과정

1. 개발자가 자바 소스코드(.java)를 작성한다.
2. 자바 컴파일러가 자바 소스코드(.java)파일을 읽어 바이트코드(.class)코드로 컴파일 합니다. 바이트코드(.class)파일은아직 컴퓨터가 읽을 수 없는 JVM(자바 가상 머신)이 읽을 수 있는 코드이다.(java - > class)
3. 컴파일된 바이트코드(.class)를 JVM의 클래스로더(Class Loader)에게 전달한다.
4. 클래스 로더는 동적로딩(Dynamic Loading)을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역(Runtime Data Area의 Method Area), 즉 JVM의 메모리에 올린다.
5. 실행엔진(Execution Engine)은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행합니다. 이 때 실행 엔진은 두 가지 방식으로 변경한다.


<br/>

## 클래스 로더(Class loader)

자바는 동적 로드, 즉 컴파일 타임이 아니라 런타임(바이트 코드를 실행할 때)에 클래스 로드하고 링크하는 특징이 있다. 

클래스 로더(Class Loader)가 컴파일된 자바 바이트코드를 런타임 데이터 영역(Runtime Data Areas)에 로드하고, 실행 엔진(Execution Engine)이 자바 바이트코드를 실행한다.

- 자세히
    
    ### 클래스 로더 위임 모델
    
    클래스 로더가 클래스 로드를 요청받으면, 클래스 로더 캐시, 상위 클래스 로더, 자기 자신의 순서로 해당 클래스가 있는지 확인한다. 즉, 이전에 로드된 클래스인지 클래스 로더 캐시를 확인하고, 없으면 상위 클래스 로더를 거슬러 올라가며 확인한다. 부트스트랩 클래스 로더까지 확인해도 없으면 요청받은 클래스 로더가 파일 시스템에서 해당 클래스를 찾는다.
    
    - 부트스트랩 클래스 로더: JVM을 기동할 때 생성되며, Object 클래스들을 비롯하여 자바 API들을 로드한다. 다른 클래스 로더와 달리 자바가 아니라 네이티브 코드로 구현되어 있다.
    - 익스텐션 클래스 로더(Extension Class Loader): 기본 자바 API를 제외한 확장 클래스들을 로드한다. 다양한 보안 확장 기능 등을 여기에서 로드하게 된다.
    - 시스템 클래스 로더(System Class Loader): 부트스트랩 클래스 로더와 익스텐션 클래스 로더가 JVM 자체의 구성 요소들을 로드하는 것이라 한다면, 시스템 클래스 로더는 애플리케이션의 클래스들을 로드한다고 할 수 있다. 사용자가 지정한 $CLASSPATH 내의 클래스들을 로드한다.
    - 사용자 정의 클래스 로더(User-Defined Class Loader): 애플리케이션 사용자가 직접 코드 상에서 생성해서 사용하는 클래스 로더이다.
    
    ### 특징
    
    - 계층 구조: 클래스 로더끼리 부모-자식 관계를 이루어 계층 구조로 생성된다. 최상위 클래스 로더는 부트스트랩 클래스 로더(Bootstrap Class Loader)이다.
    - 위임 모델: 계층 구조를 바탕으로 클래스 로더끼리 로드를 위임하는 구조로 동작한다. 클래스를 로드할 때 먼저 상위 클래스 로더를 확인하여 상위 클래스 로더에 있다면 해당 클래스를 사용하고, 없다면 로드를 요청받은 클래스 로더가 클래스를 로드한다.
    - 가시성(visibility) 제한: 하위 클래스 로더는 상위 클래스 로더의 클래스를 찾을 수 있지만, 상위 클래스 로더는 하위 클래스 로더의 클래스를 찾을 수 없다.
    - 언로드 불가: 클래스 로더는 클래스를 로드할 수는 있지만 언로드할 수는 없다. 언로드 대신, 현재 클래스 로더를 삭제하고 아예 새로운 클래스 로더를 생성하는 방법을 사용할 수 있다.
    
    ### 클래스 로드 과정
    
    - 로드: 클래스를 파일에서 가져와서 JVM의 메모리에 로드한다.
    - 검증(Verifying): 읽어 들인 클래스가 자바 언어 명세(Java Language Specification) 및 JVM 명세에 명시된 대로 잘 구성되어 있는지 검사한다. 클래스 로드의 전 과정 중에서 가장 까다로운 검사를 수행하는 과정으로서 가장 복잡하고 시간이 많이 걸린다. JVM TCK의 테스트 케이스 중에서 가장 많은 부분이 잘못된 클래스를 로드하여 정상적으로 검증 오류를 발생시키는지 테스트하는 부분이다.
    - 준비(Preparing): 클래스가 필요로 하는 메모리를 할당하고, 클래스에서 정의된 필드, 메서드, 인터페이스들을 나타내는 데이터 구조를 준비한다.
    - 분석(Resolving): 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경한다.
    - 초기화: 클래스 변수들을 적절한 값으로 초기화한다. 즉, static initializer들을 수행하고, static 필드들을 설정된 값으로 초기화한다.
    
    ### 클래스 로더 세부 동작
    
    클래스 로더가 아직 로드되지 않은 클래스를 찾으면, 다음 그림과 같은 과정을 거쳐 클래스를 로드하고 링크하고 초기화한다.
    
    1. **로드** : 클래스 파일을 가져와서 JVM의 메모리에 로드합니다.
    2. **검증** : 자바 언어 명세(Java Language Specification) 및 JVM 명세에 명시된 대로 구성되어 있는지 검사합니다.
    3. **준비** : 클래스가 필요로 하는 메모리를 할당합니다. (필드, 메서드, 인터페이스 등등)
    4. **분석** : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경합니다.
    5. **초기화** : 클래스 변수들을 적절한 값으로 초기화합니다. (static 필드)
    

<br/>

## 클래스 로더 실행 엔진

클래스 로더를 통해 JVM 내의 런타임 데이터 영역에 배치된 바이트코드는 실행 엔진에 의해 실행된다. 실행 엔진은 자바 바이트코드를 명령어 단위로 읽어서 실행한다.

자바 바이트코드는 기계가 바로 수행할 수 있는 언어보다는 비교적 인간이 보기 편한 형태로 기술된 것이다. 그래서 실행 엔진은 이와 같은 바이트코드를 실제로 JVM 내부에서 기계가 실행할 수 있는 형태로 변경하며, 그 방식은 다음 두 가지가 있다.

### 인터프리터

바이트 코드 명령어를 하나씩 읽어서 해석하고 실행한다. 하나씩 해석하고 실행하기 때문에 바이트코드 하나하나의 실행은 빠르나, 인터프리팅 결과의 실행은 느리다는 단점을 가진다.

### JIT 컴파일러(Just-In-Time Compiler)

인터프리터의 단점을 보완하기 위해 도입된 방식이다. 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고 이후에는 해당 메서드를 더이상 인터프리팅 하지 않고, 바이너리 코드로 직접 실행하는 방식이다. 하나씩 인터프리팅하여 실행하는 것이 아니라 바이트 코드 전체가 컴파일된 바이너리 코드를 실행하는 것이기 때문에 전체적인 실행속도는 인터프리팅 방식보다 빠르다.

JIT 컴파일러가 컴파일하는 과정은 바이트코드를 하나씩 인터프리팅하는 것보다 훨씬 오래 걸리므로, 만약 한 번만 실행되는 코드라면 컴파일하지 않고 인터프리팅하는 것이 훨씬 유리하다. 따라서, JIT 컴파일러를 사용하는 JVM들은 내부적으로 해당 메서드가 얼마나 자주 수행되는지 체크하고, 일정 정도를 넘을 때에만 컴파일을 수행한다.


<br/>

## CPython, Jython, PyPy … ?

### CPython

- C/C++언어로 구현된 Python
- Python은 C언어로 작성된 컴파일러를 활용해서 라인단위로 Code를 인터프리팅 하여 실행한다.
    - CPython으로 작성된 컴파일러 이기 때문에, CPython으로 패키지를 작성하는것 역시 가능하다.
- Python의 고질적인 GIL 문제는 CPython의 GC때문에 존재한다.

### **Jython**

- JVM을 활용하는 Python구현체 중 하나로, Python syntax로 작성된 코드를 JVM이 이해할 수 있는 바이트코드로 만들고, 이 바이트코드를 JVM이 실행하게 된다.
- GC가 variable counting이 아닌 JVM에서 사용되는 GC으로 구현 되어있기 때문에 GIL을 사용하지 않는다는 장점이 있다.

### PyPy

- pypy는 CPython의 컴파일러를 python으로 작성한 구현체이다.(self-hosted compiler)

### ****Cython****

- C와 유사한 문법으로 함수를 작성하고, 이를 CPython 패키지 형태로 만들어준다.

### IronPython

- C#의 .NET 프렘임워크를 사용한 Python 구현체이다.

https://seohs.tistory.com/259

https://live-everyday.tistory.com/67

https://live-everyday.tistory.com/69

https://hbesthee.tistory.com/1410

https://d2.naver.com/helloworld/1230

https://steady-snail.tistory.com/67

https://www.sktenterprise.com/bizInsight/blogDetail/dev/2434
