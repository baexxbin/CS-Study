# 메모리 할당과 단편화

<br>

## 메모리 할당(Memory Allocation)

> 메모리는 메모리에 상주하는 운영체제를 위한 것과 사용자 프로세스를 위한 것으로 나뉘는데, 메인 메모리는 운영체제뿐만 아니라 여러 사용자의 프로세스도 수용해야 한다. 따라서 메모리의 각 영영은 목적에 맞게 효율적으로 관리되어야 한다.
- 컴퓨터를 사용하면 여러 프로그램을 동시에 사용하는데 이것을 멀티 프로그래밍 환경이라고 함
  - 이런 환경에서 여러 프로세스가 동시에 메모리에 올라와 있는 것이 바람직하기 때문에 메모리에 올라오기 위해 입력 큐에서 기다리는 프로세스들에게 메모리를 얼만큼씩 할당하는 것이 좋은지 생각해야 함 
- 메모리 할당은 `연속 메모리 할당`과 `비연속 메모리 할당`으로 나뉨

<br>

### Swapping(스와핑)

<img src="https://github.com/jmxx219/CS-Study/assets/64017307/f230dcac-2d45-4767-9061-430ee2d500fb" width="400" height="200"/>
<br>  

- 메모리에서 사용되지 않는 일부 프로세스를 보조기억장치로 내보내고 실행할 프로세스를 메모리로 들여보내는 메모리 관리 기법
  - 스왑 영역(swap space) : 프로세스들이 쫓겨나는 보조기억장치의 일부 영역
  - 스왑 아웃(swap-out) : 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것
  - 스왑 인(swap-in) : 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것

- 스왑아웃 된 프로세스가 다시 스왑 인될 때는 스왑 아웃되기 전의 물리주소와 다른 주소에 적재 될 수 있음
- 스와핑을 이용하면 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시 실행 할 수 있음


<br>
<br>


## 메모리 단편화(Memory Fragmentation)

> RAM에서 메모리의 공간이 작은 조각으로 나뉘어져 사용 가능한 메모리가 충분히 존재하지만 할당(사용)이 불가능한 상태를 메모리 단편화가 발생했다고 한다.

<br>

### 내부 단편화(Internal Fragmentation)

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb8a0TV%2FbtrB67aO3nz%2FRudTKjcRjlJLtVzx1k6bj1%2Fimg.jpg" width="400"/>

- 프로그램의 크기보다 분할의 크기가 더 큰 경우, 프로세스가 사용하는 메모리 공간 중 남는 부분이 발생하는 현상
- 하나의 분할 내부에 사용되지 않는 메모리 조각이 생기는 현상
  - 하나의 분할 공간에는 하나의 프로세스만 들어가기 때문(고정 분할 방식 특징)에 다른 프로그램이 들어갈 수 없고, 이는 결국 메모리 낭비로 이어짐

<br>

### 외부 단편화(External Fragmentation)

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbH0XUM%2FbtrB6tMdcFO%2FyrlxwHGiaPw8ywzWkZ761K%2Fimg.jpg" width="350"/>

- 프로그램의 크기보다 분할의 크기가 작은 경우, 분할이 비어있음에도 프로그램을 적재하지 못하는 현상
- 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상
  - 메모리가 할당되고 해제되는 작업이 반복적으로 일어날 때, 할당된 메모리 사이 중간중간 마다 사용하지 않는 작은 공간이 생김
  - 이때 작은 메모리들의 합인 총 메모리 공간은 충분하지만, 실제 할당 가능한 공간은 부족하여 할당할 수 없는 상황

<br>
<br>

## 연속 메모리 할당(Contiguous Memory Allocation)

> 프로세스를 메모리에 올릴 때 주소 공간을 메모리의 한 곳에 연속적으로 적재하는 방식으로, 물리적 메모리를 다수의 분할로 나누어 하나의 분할에 하나의 프로세스가 적재되도록 함

<br/>

### 메모리 연속 할당 기법

- **고정 분할(내부단편화) 방식**
  - 물리적 메모리를 정해진 개수만큼의 영구적인 분할로 미리 나누어두고 각 분할에 하나의 프로세스를 적재하는 방식
  - 분할의 크기는 모두 동일할 수도 있고 다를 수도 있음
  - 동시에 메모리에 올릴 수 있는 프로그램의 수가 고정되어 있고, 수행 가능한 프로그램의 최대 크기 또한 제한됨
  - 내부단편화와 외부단편화 모두 발생
- **가변/동적 분할(외부단변화) 방식**
  - 메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식
  - 프로그램의 크기를 고려해서 메모리를 할당하고 이를 기술적으로 관리할 수 있는 기법이 필요(동적 메모리 할당 문제)
  - 프로세스에 딱 맞게 메모리 공간을 사용하기 때문에 내부 단편화 발생 x
  - 메모리에 새로운 프로세스를 올릴 공간이 충분하지 않으면 외부 단편화 발생 o

<br/>

### 동적 메모리 할당 문제를 해결하는 방법

> 남은 메모리 공간 중에 프로세스를 어디에 올려야하는지 결정한다.  
> 성능 : 최초, 최적 모두 시간 및 공간 효율성 측면에서 최악보다 좋다.  
  
  
#### 1. 최초 적합(First fit)
- 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식
- 검색을 최소화 할 수 있다
- 시간적 측면에서 효율적이다
- 빠른 할당이 가능하다

```
Ex) 
빈공간A -> 빈공간B -> 빈공간C -> 빈공간D <br>
운영체제가 이 순서대로 빈 공간을 발견했다면, 빈공간A에 먼저 할당하는 방식
```

<br>

#### 2. 최적 적합(Best fit)
- 운영제체가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간중에서 가장 작은(가장 크기가 비슷한)공간에 프로세스를 배치하는 방법
  - 내부 단편화를 최소화하는 공간에 배치
- 공간에 대한 목록이 그 공간의 크기 순서대로 정렬되어 있지 않다면, 최적인 곳을 찾기 위해 전체를 검색해야한다. = 시간적 오버헤드를 발생한다
- 외부 단편화를 초래, 메모리 집약 횟수를 증가시킨다
- 공간적인 측면에서 효율적이다

```
Ex) 
적재할 프로세스가 18Mb 일떄, <br>
| 빈공간A(50Mb) | 빈공간B(30Mb)| 빈공간C(20Mb)| 빈공간(70Mb)D | <br>
운영체제가 빈공간C에 적재한다 <br>
```

<br>

#### 3. 최악 적합(Worst fit)
- 운영체제가 빈 공간을 모두 검색 해 본 후, 가장 큰 공간에 프로세스를 배치하는 방법
- 최적 적합과 마찬가지로, 크기 순서대로 정렬되어 있지 않다면 전체를 검색한다. = 오버헤드 발생
- 최악적합은 가장 큰 공백에 배치하는 전략이므로, 큰 가용 공간에 프로그램을 할당하기 때문에 남은 공간도 여전히 크므로 다른 프로그램이 실행이 가능하다.

```
Ex) 
적재할 프로세스가 18Mb 일떄, <br>
| 빈공간A(50Mb) | 빈공간B(30Mb)| 빈공간C(20Mb)| 빈공간(70Mb)D | <br>
운영체제가 빈공간D에 적재한다 <br>
```


<br>
<br>

## 불연속 메모리 할당(Non-Contiguous Memory Allocation)

> 프로세스를 메모리에 올릴 때, 주소 공간을 물리 메모리의 여러 영역에 분산하여 적재하는 방식 

- 가변(동적) 분할 방식 모두 결국에는 외부 단편화 문제가 발생하게 됨
  - 어느 공간에 넣든 결국에는 자투리 공간이 생기기 때문에
- 불연속 메모리 할당 기법으로 외부 단편화 문제를 해결할 수 있음

<br>

### 메모리 불연속 할당 기법

[페이징(paging)](https://github.com/jmxx219/CS-Study/blob/main/operating-system/%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98%EA%B3%BC%20%ED%8E%98%EC%9D%B4%EC%A7%80.md#%ED%8E%98%EC%9D%B4%EC%A7%95)과 [세그먼테이션(segmentation)](https://github.com/jmxx219/CS-Study/blob/main/operating-system/%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98%EA%B3%BC%20%ED%8E%98%EC%9D%B4%EC%A7%80.md#%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%85%8C%EC%9D%B4%EC%85%98) 참고


<br>
<br>


### Ref


- [메모리 단편화(Memory Fragmentation)가 무엇이고 왜 발생하는가?](https://jeong-pro.tistory.com/91)
- [[운영체제 11편] 메모리 할당 (연속할당 방식)](https://baebalja.tistory.com/416)
- [[OS] 사용자 프로그램 물리 메모리 할당, 연속할당과 불연속 할당에 관하여](https://middlefitting.tistory.com/52)