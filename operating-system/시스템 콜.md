# 운영체제

- 컴퓨터 시스템의 자원들을 효율적으로 관리하고, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임
  - 좁은 의미의 OS: 커널을 의미하며, 컴퓨터가 켜진 후 항상 메모리에 상주하는 운영 체제의 핵심 부분
  - 넓은 의미의 OS: 커널을 포함해서 메모리에 상주하지 않는 다양한 유틸리티를 모두 포괄하는 개념

<br>

## 시스템 콜

* 시스템 콜이란 응용 프로그램의 요청에 따라 커널에 접근하기 위한 인터페이스 역할을 한다.  
* 풀어 설명하면 사용자 모드에서 커널 모드로 전환하기 위한 호출이다. 
* 사용자가 일반적으로 사용하는 응용 프로그램은 유저 레벨의 함수 만으로는 기능을 구현하기 힘들기 때문에, 커널의 도움을 받아야 한다.
* 운영체제는 하드웨어를 직접 관리하고, 응용 프로그램은 운영체제가 제공하는 인터페이스를 통해서만 자원을 사용할 수 있다.
* 운영체제에 의해 실행될 동작을 사용자 프로세스가 요청할 수 있게 하는 것
  - 즉, 시스템 콜은 커널 영역의 기능을 사용자 모드가 사용할 수 있도록, 필요한 기능을 수행할 수 있게 해준다.
  - 보통 직접적으로 시스템 콜을 사용하기 보다는 API를 통해 사용하게 된다.

<br>

## 커널

- 운영체제 중 항상 메모리에 올라가 있는 운영체제의 핵심 부분
  - 운영체제와 같이 규모가 큰 프로그램이 모두 메모리에 올라가면 메모리 공간 낭비가 심해진다.
  - 운영체제 중 항상 필요한 부분만 메모리에 올려놓고, 그렇지 않은 부분은 필요할 때만 메모리에 올려서 사용한다.
  - 이때 메모리에 상주하는 운영체제의 부분을 커널이라고 한다.
- 하드웨어와 응용 프로그램 사이에서 인터페이스를 제공하는 역할을 하고, 컴퓨터 자원들을 관리하는 역할을 한다.
  - 즉, 인터페이스로써 응용 프로그램 수행에 필요한 여러 서비스를 제공하고, 여러 하드웨어(CPU, 메모리) 등의 자원을 관리하는 역할을 한다.
- 커널은 항상 자원들을 바라보고 있기 때문에 사용자와의 상호작용은 지원하지 않는다.
  - 사용자와의 직접적인 상호작용을 위해 프로그램을 제공하는데, 대표적으로 쉘(Shell) 등이 있다.
  - 사용자는 이 쉘을 통해 커널에게 명령을 내릴 수 있다.

>  쉘(shell): 사용자가 컴퓨터에게 전달하는 명령을 해석하는 프로그램으로, 커널과 사용자 간의 다리 역할을 수행함


<br>

### 이중 동작 모드 Dual Mode Operation

* 사용자 프로그램이 하드웨어를 직접 제어하는 것을 막기 위해 CPU는 두가지 모드를 가지고 있다.
* 사용자가 접근할 수 있는 **사용자 모드**가 있고, 사용자가 접근할 수 없는 **커널 모드**있다.
* 이렇게 사용자로부터 운영체제 자원을 보호하는 장치가 바로 이중 동작 모드이다.

<br>


#### 사용자 모드 User Mode

* 개발자가 만든 응용 프로그램이나 소프트웨어가 실행되는 모드이다
* 시스템 데이터에 제한된 접근만 허용되며, 하드웨어나 시스템에 직접적으로 접근할 수 없다.
* 그렇지 않으면, 하나의 응용 프로그램이 하드웨어를 모두 점유하는 등의 위험 요소가 있기 때문이다.
* 접근을 위해서 **시스템 콜**(System Call)을 사용해야 한다.

<br>

#### 커널 모드 Kernel Mode

* 운영체제에서 동작하는 응용 프로그램을 관리하고, 하드웨어와 관련된 작업을 수행하는 모드이다.
* 다시말해 운영체제가 CPU의 제어권을 가지고 커널이 작업을 수행하는 모드이다.
* 시스템의 모든 자원(드라이버, 메모리, CPU 등)에 접근할 수 있고, 모든 CPU 명령을 실행할 수 있다.
* 응용 프로그램은 사용자 모드에서 실행되다가 시스템 자원을 사용해야 할 때, 시스템 콜을 호출하여 커널모드로 전환하고 작업을 수행한 뒤에는 다시 사용자 모드로 전환한다.

<br>


#### 모드 전환 Mode Switching

* 사용자 모드에서 시스템 콜을 호출하면 커널 모드로 전환되고, 커널 모드에서 시스템 콜을 처리한 뒤 다시 사용자 모드로 전환된다.
* 이때 사용자 모드에서 커널 모드로 전환하는 것을 **모드 전환**이라고 한다.
* 모드 전환은 CPU가 수행하며, 이때 CPU는 [**인터럽트**](https://github.com/jmxx219/CS-Study/blob/main/OperatingSystem/Interrupt.md#%EC%9D%B8%ED%84%B0%EB%9F%BD%ED%8A%B8)를 사용한다.


<br>

## 처리 과정

1. 사용자 프로세스가 시스템 콜 호출한다.(사용자 모드에서 커널 모드로 진입)
2. 커널은 요청 받은 시스템 콜에 대응하는 고유 번호를 확인하고, 번호에 맞는 서비스 루틴을 호출한다.
   - 커널은 내부적으로 시스템 콜을 구분하기 위해 기능별로 고유 번호를 할당하고, 그 번호에 해당하는 제어 루틴을 정의해둔다.
3. 커널은 서비스 루틴을 처리하고, 사용자 모드로 전환한다.

<br>

## 시스템 콜 유형

### 프로세스/스레드 컨트롤

- 프로세스 생성 및 종료
- 메모리에 로드, 실행 메모리 할당
- 예시) `fork()`, `wait()`, `exec()`, `exit()`

### 파일 I/O 관리

- 파일 생성, 파일 삭제
- 열기, 닫기, 읽기, 쓰기 등
- 예시) `open()`, `read()`, `write()`, `close()`

### 디바이스 매니지먼트

- 디바이스 요청 및 해제
- 읽기, 쓰기
- 예시) `read()`, `write()`

### 정보 관리

- 시간 확인, 시간 지정
- 시스템 데이터 확인, 지정
- 예시) `time()`, `gettimeofday()`

### 통신

- 커뮤니케이션 연결 생성 및 삭제
- 메시지 송신, 수신, 상태 정보 전달
- 예시) `pipe()`, `send()`

### 보안

- Permission 획득, 설정
- 예시) `chmod()`, `chown()`


<br>

<br/>

* 위의 예시 코드들은 리눅스에서 제공하는 시스템 콜 관련 함수들이다. 
* 리눅스는 C언어로 개발되어 있기에 함수들도 C언어로 구현되어 있다.

<br>

## 프로그래밍 언어와 시스템 콜

* 하드웨어 혹은 시스템 관련 기능은 어떤 프로그램이라도 반드시 시스템 콜을 통해서만 사용할 수 있다. 
* 프로그래밍 언어를 사용하면서 파일 작업, 네트워크 작업 또는 프로세스/스레드 관련 작업을 할 때 직접 시스템 콜을 사용한 적은 없다. 
* 대부분의 프로그래밍 언어는 시스템 콜을 포장(Wrapping)하여 간접적으로 사용할 수 있도록 제공하기 때문이다.

<br>

**java.lang.Thread 예제**

```java

Thread thread = new Thread();
thread.start();

```

<br>


```java
public synchronized void start() {

        boolean started = false;
        try {
            start0();
            started = true;
        } finally {}
    }

    private native void start0();
```

<br>

* Thread 클래스의 `start()` 메서드 내부를 살펴보면, `start0()` 메서드를 호출하고 있다.
* `start0()` 메서드는 따로 구현체는 없고 `native`로 선언되어 있다.
* 자바에서 `native`로 선언된 메서드는 자바가 아닌 다른 언어로 구현된 메서드를 호출한다.
* 즉 자바 네이티브 인터페이스 (Java Native Interface, JNI)를 통해 기반이 되는 OS의 시스템 콜을 호출한다. 
* 만약 리눅스 기반이라면 `start0()` 메서드는 `clone()`이라는 시스템 콜을 호출한다.
* 이렇게 개발자들도 프로그래밍 언어를 통해 간접적으로 시스템 콜을 사용할 수 있다.
