### 리플렉션이란

- 자바에서는 컴파일러가 자바 코드를 바이트 코드로 바꿔준다. 클래스 로더는 이 바이트 코드를 읽어 JVM의 메모리 영역에 저장한다. 리플렉션은 이 JVM의 메모리 영역에 저장된 클래스의 정보(멤버 변수, 메서드, 생성자)를 런타임 시에 꺼내와서 사용하는 기술이다. 
즉, 클래스의 구조와 동작을 동적으로 탐색하고 제어할 수 있게된다. 하지만 성능상의 오버헤드와 보안상의 이슈가 있으므로 신중하게 사용해야 한다.

<br/>

### 리플렉션이 제공하는 기능들
- 클래스에 붙은 어노테이션 조회
- 클래스 생성자 조회
- 클래스 필드 조회
- 클래스 메서드 조회
- 부모 클래스, 인터 페이스 조회 등등

<br/>

### 클래스 가져오는 방법

1. {클래스 타입}.class
```java
Class<?> clazz = person.class;
```
    
2. {인스턴스}.getClass()

```java
Person person = new Person("잡스");
Class<?> clazz = person.getClass();
```

3. Class.forName(”{전체 도메인 네임}”)

```java
Class<?> clazz = Class.forName("org.example.person")
```

### class 메서드 사용시 주의점

- getMethods() : 상속한 메서드를 포함하여 public인 메서드들을 모두 가져온다
- getDeclaredMethods() : 상속한 메서드는 제외하고 직접 클래스에 선언한 메서드들을 모두 가져온다

### 리플렉션을 이용해서 객체 생성해보기

```java
Class<?> clazz = person.class;
Constructor<?> constructor = clazz.getDelaredConstructor();
Object person1 = constructor.newInstance();
```

이 밖에도 메서드 조회, 필드 조회 등의 클래스에 관련된 여러 정보를 찾을 수 있다. 

<br/>

### 기본 생성자도 리플렉션 때문에 필요하다

리플렉션은 기본 생성자로 객체를 생성하고 필드를 통해 값을 넣어준다. 만약 기본 생성자가 없다면 여러 생성자가 있을 때, 리플렉션은 어느 생성자로 객체를 생성해야 하는지 구별할 수 없다. 그렇기에 모든 클래스에 기본 생성자가 필요하다.

### 리플렉션은 왜 쓸까?

리플렉션은 프레임워크나 라이브러리에서 많이 사용. 이 둘은 컴파일 시점까지 개발자가 구현한 객체들의 타입을 모름. 이러한 문제를 동적으로 해결하기위해서 리플렉션을 사용. 
ex) JPA, Mockito, JUnit …

### 리플렉션의 활용 예시

- 스프링 컨테이너의 의존성 관리를 예로 들 수 있다. @Component가 붙은 클래스를 스프링 컨테이너가 리플렉션을 활용해 검색하고, 생성자 또한 리플렉션으로 호출해서 인스턴스를 만든다. 이렇게 스프링 컨테이너가 관리해주는걸 생각하면 쉽게 이해할 수 있다.



### 보안상의 문제

- 리플렉션을 사용하면 private이나 protected로 선언된 멤버 변수, 메서드에도 접근할 수 있다. 일반적인 접근 제어 규칙을 우회할 수 있는 가능성이 있으며, 클래스의 내부 구현 및 민감한 정보가 노출될 수 있다.


### 리플렉션의 단점

컴파일 시점이 아니라 런타임 시점에서 클래스를 분석하기에 성능저하가 발생한다. 또한 리플렉션을 사용해 코드를 구현하면 코드가 길어진다.  보안상의 문제에서도 말했듯이 접근 제어자를 무시하고 접근할 수 있기에 추상화가 깨지는 단점도 존재한다. 그렇기에 꼭 필요한 경우에만 리플렉션을 사용해야 한다.
