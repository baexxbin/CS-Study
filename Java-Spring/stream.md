# 스트림

스트림은 자바 8 API에 새로 추가된 기능이다. 

<자바의 정석> 에서는 스트림은 ‘데이터의 흐름’ 이라고 정의해 놨다. <자바 인 액션>에서는 스트림이란 ‘데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소’ 라고 설명해놨다.  자바의 정석 설명은 스트림 자체에 대한 설명에 가깝고 자바 인 액션 설명은 스트림 인터페이스에 대한 설명이라고 느꼈다. 

<br>

## 스트림 API 특징들

- 선언형 : 더 간결하고 가독성이 좋아진다.
- 조립할 수 있음 : 유연성이 좋아진다.
- 병렬화 : 성능이 좋아진다.

스트림은 데이터 소스를 추상화하고 자주 사용하는 메서드들을 정의해 놓았다. 추상화 시켰다는 것은 데이터 소스가 리스트이건 배열이건 간에 같은 방식으로 다룰 수 있게 되었다는 것과 코드의 재사용성이 높아진다는 것을 의미한다.

<br>

### 스트림의 특징들

- 스트림은 데이터소스를 읽기만 할뿐 변경하지 않는다.
- 스트림은 일회용이다. 스트림을 한번 사용하면 닫혀서 다시 사용할 수 없다. 필요하다면 다시 스트림을 생성해야 한다.
- 스트림은 작업을 내부 반복으로 처리한다.

<br>

### 스트림 연산

- 중간 연산 : 연산 결과가 스트림. 스트림에 연속해서 중간 연산을 할 수 있음
- 최종 연산 : 연산 결과가 연산. 스트림의 요소를 소모하므로 단 한 번만 가능

ex) stream.distinct().limit(5).sorted().forEach(System.out::println)

- 중간 연산
    - distinct()
    - limit(5)
    - sorted()
- 최종 연산 : forEach(System.out::println)

<br/>

## 중간 연산과 최종 연산들

중간 연산

- distinct() : 중복 제거
- filter() : 조건에 안 맞는 요소 제거
- limit() : 스트림 일부만 가져옴
- sorted() : 스트림 요소를 정렬
- map() : 스트림 요소를 변환

최종 연산

- forEach() : 각 요소에 지정된 작업 수행
- count() : 스트림의 요소 개수 반환
- max(), min() : 최대, 최소값 반환
- findAny(), findFirst() : 스트림 요소 중 하나 반환
- toArray() : 스트림의 모든 요소를 배열로 반환
- collect() : 스트림의 요소를 수집한다. 주로 요소들을 그룹화하거나 컬렉션에 담아 반환

<br/>

## 스트림과 컬렉션

<자바 인 액션>에서는 둘을 계산 시점을 기준으로 비교하고 있다. 컬렉션은 “현재” 자료구조가 포함된 모든 값을 메모리에 저장하고 있는 자료구조다. 반면에 스트림은 요청할 때만 요소를 계산하는 자료구조다. 

컬렉션은 반복자(for, while)를 이용해서 사용자가 직접 요소를 반복해야 한다. 이 반복을 외부 반복이라고 부른다. 

스트림은 반복을 알아서 처리해주고 결과 스트림 값을 어딘가에 저장해주는 방식을 사용한다. 이를 내부 반복이라고 한다. 

<br>

<외부반복 - 반복자 있음>

```java
List<String> names = new ArrayList<>();
for(Dish dish: menu) {
    names.add(dish.getName());
}
```

<br>

<내부반복 - 반복자 없음>

```java
List<String> names = menu.stream().map(Dish::getName).collect(toList());
```

내부 반복의 장점

1. 반복자 없음 : 개발자가 직접 반복문을 처리해주지 않아도 됨.
2. 병렬 처리 : 외부 반복을 사용하면서 병렬처리를 위해서는 스레드간의 공유자원에 대한 동기화 처리를 따로 해줘야 한다. 하지만 내부 반복은 이를 관리할 필요가 없음

<br/>

## 스트림의 병렬 처리

- 한 가지 작업을 여러 서브 작업으로 나누고, 서브 작업들을 분리된 스레드에서 병렬적으로 처리하고, 결과들을 최종 결합하는 방법이다.
- 자바는 ForkJoinPool 프레임워크를 이용해서 병렬 처리를 한다.
    - main 스레드는 스트림을 처리하기 위한 기본 스레드이고 나머지 스레드는 ForkJoinPool 프레임워크를 통해서 생성된다.
    - 해당 프레임워크의 설정해줘서 생성할 스레드 개수를 제어할 수 있다.
    
- 스트림은 병렬처리와 순차처리를 합쳐서 사용할 수 있다.
    - parallel() : 순차 처리 스트림을 병렬처리로 변경
    - sequential() : 병렬처리 스트림을 순차 처리로 변경
    
    ex) `list.stream().limit(100).parallel().reduce(Integer::sum);`  
    위 코드는 limit() 까지는 순차 처리로 진행하고 이후엔 병렬처리로 진행한다.

<br/>    

## 하지만 병렬 처리는 되도록 쓰지말자

데이터소스의 자료구조에 따라 참조 지역성이 다르다. 참조들이 가리키는 실제 객체가 메모리에서 서로 떨어져 있을 수 있는데, 이런 경우엔 참조 지역성이 나쁘다. 참조 지역성이 낮으면 스레드는 데이터가 주 메모리에서 캐시 메모리로 전송되어 오기를 기다리는 시간이 늘어난다. 따라서 참조 지역성은 다량의 데이터를 처리하는 벌크 연산을 병렬화할 때 중요한 요소로 작용한다. 

또한 최종 연산의 동작 방식에 따라서도 병렬처리는 효과가 달라진다. anyMatch(), allMatch() 처럼 조건에 맞으면 바로 반환되는 연산은 병렬화에 적합하지만 collect() 메서드와 같이 합치는 작업은 부담이 크다. 

즉, 병렬화를 잘못 사용하면 성능이 나빠지거나, 예상치 못한 동작이 발생할 수 있다. 그렇기에 계산도 정확하고 성능이 빨라질 거라는 확신이 없이는 스트림의 병렬화를 시도하지 않는게 좋다. 병렬화로 인한 성능이 좋아졌음을 지표로 확인했을 때만 운영 코드에 사용하는 것이 좋다 - <이펙티브 자바>

<br/>

## 스트림에서 사용하는 함수형 인터페이스

1. Predicate<T>
    
    참 거짓을 판단하는 인터페이스. 매개 변수를 받아서 결과값을 반환
    
    ```java
    List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    
            List<Integer> evenNumbers = numbers.stream()
                    .filter(n -> n % 2 == 0)
                    .collect(Collectors.toList());
    ```
    

2. Function<T,R> 
    
    일반적인 함수. 매개변수를 받아서 결과를 반환
    
    ```java
    List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
    
            List<Integer> squares = numbers.stream()
                    .map(n -> n * n) 
                    .collect(Collectors.toList());
    ```
    

3. Cunsumer<T> 
    
    매개변수만 있고 반환값은 없는 상태
    
    ```java
    List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
    
            numbers.forEach(number -> System.out.println(number));
    ```
    

4. Supplier<T>
    
    매개변수는 없고 반환값만 있는 상태
    
    ```java
    Supplier<Integer> randomNumberSupplier = () -> new Random().nextInt();
    
            Stream<Integer> randomStream = Stream.generate(randomNumberSupplier)
                    .limit(5);
    ```
    

<br>

반환값의 유뮤에 따라 분류할 수 있는 4개의 함수형 인터페이스 모두 다양한 형태로 스트림에서 활용되고 있다.
