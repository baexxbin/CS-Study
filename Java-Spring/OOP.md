# 객체지향 프로그래밍 OOP (Object Oriented Programing)

## 객체지향이란

* 객체지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 객체들이 서로 협력하는 형태의 구조를 지향한다
* 객체는 각자 맡은 책임이 있고, 서로 메시지를 주고받으면서 협력한다.

<br>

## 객체지향의 핵심

* 역할과 책임 협력은 객체지향의 핵심이다.
* 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 **협력**이라고 한다.
* 그리고 객체가 협력에 참여하기 위해 수행하는 로직을 **책임**이라고 부른다.
* 객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 **역할**을 구성한다.

<br>

* **협력**
  * 두 객체의 협력에 사용되는 유일한 수단은 **메시지 전송**이다. 
  * 다른 객체에게 도움을 요청하기 위해 **메시지**를 전송하고, 메시지를 수신한 객체는 메시지를 처리하는 데 적합한 **메서드**를 자율적으로 선택한다.
* **책임**
  * 협력에 참여하기 위해 객체가 수행하는 행동을 **책임**이라고 한다.
  * 객체가 책임을 수행하는 방법을 **메서드**라고 부른다.
  * **책임 주도 설계**(Responsibility-Driven Design)란 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 설계하는 방법이다.
* **역할**
  * 객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합을 **역할**이라고 한다.
  * 역할을 통해서 유연하고 재사용 가능한 협력을 얻을 수 있다.
  * 역할은 다른 것으로 교체할 수 있는 책임의 집합이다.
  * 때문에 특정 역할을 수행할 수 있는 객체라면 어떠한 객체로 바꿔 끼워도 상관 없다.

<br>

## 특징

### 추상화

* 추상화란 객체들의 공통된 특징을 파악하여 하나의 개념으로 다루는 것이다.
* 객체지향 프로그래밍에서는 추상화를 통해 클래스를 정의하고 객체를 생성한다.

<br>

### 상속

* 상속은 새로운 클래스가 기존의 클래스의 자료와 연산을 이용할 수 있게 하는 기능이다.
* 상속을 통해 새로운 클래스를 작성할 때 기존 클래스의 자료와 연산을 수정하지 않고도 확장할 수 있다.
* 기존의 클래스를 상위 클래스, 부모 클래스라 부르며, 상속을 받는 클래스를 하위 클래스, 자식 클래스, 파생 클래스라 부른다.
* 상속을 통해 기존의 클래스를 상속받은 하위 클래스를 이용해 프로그램의 요구에 맞추어 클래스를 수정할 수 있고, 클래스 간의 종속 관계를 형성함으로써 객체를 조직화할 수 있다.

<br>

### 다형성

* 다형성은 하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것을 의미한다.
* 일반적으로 오버라이딩과 오버로딩을 말한다.
* **오버로딩**(Overloading)은 같은 이름의 메서드가 매개변수의 타입과 개수를 다르게 하여 정의하는 것을 의미한다.
* **오버라이딩**(Overriding)은 상위 클래스가 가지고 있는 메서드를 하위 클래스가 재정의하여 사용하는 것을 의미한다.

<br>

**오버로딩 예시**

```java
public class Calculator {
    public int sum(int a, int b) {
        return a + b;
    }
    
    public int sum(int a, int b, int c) {
        return a + b + c;
    }
    
    public double sum(double a, double b) {
        return a + b;
    }
    
    public int sum(int x, int y) { // 이 메서드는 컴파일 에러가 발생한다.
        return x + y;              // 첫번째 메서드와 메서드의 시그니처가 같기 때문이다.
    }
}
```


<br>

**오버라이딩 예시**

```java
public class Animal {
    public void move() {
        System.out.println("동물이 움직입니다.");
    }
}

public class Human extends Animal {
    @Override
    public void move() {
        System.out.println("사람이 두 발로 걷습니다.");
    }
}
```

<br>

> `@Override` 어노테이션은 컴파일러에게 해당 메서드가 오버라이딩된 메서드임을 알려준다.  
> 만약 해당 메서드가 오버라이딩된 메서드가 아니라면 컴파일 에러를 발생시킨다.  
> 따라서 `@Override` 어노테이션을 사용하면 코드의 가독성을 높이고, 버그를 방지할 수 있다.

<br>


<br>

### 캡슐화

* 캡슐화는 객체의 상태와 행동을 객체 안에 모으고, 내부 구현을 외부로부터 감추는 것을 말한다.
* 다시말해 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 종류다.
* 접근 제어자를 `private`으로 설정하여 캡슐화를 구현할 수 있다.

<br>

#### 응집도와 결합도

* 응집도는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다.
* 모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 그 모듈은 높은 응집도를 가진다.
* 모듈 내의 요소들이 서로 다른 목적을 추구한다면 그 모듈은 낮은 응집도를 가진다.
* 하나의 변경을 수용하기 위해 다수의 모듈이 함께 변경돼야 한다면 응집도가 낮은 것이고, 하나의 모듈만 변경된다면 응집도가 높은 것이다.

<br>

<img alt="image" height="200" src="https://github.com/reddevilmidzy/CS-Study/assets/78539407/2356f3db-4b8b-4d1b-bdf6-9b360de0ddf6"/>


<br>

* 결합도는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도이다.
* 어떤 모듈이 다른 모듈에 대해 너무 자세한 부분까지 알고 있다면 두 모듈은 높은 결합도를 가진다.
* 어떤 모듈이 다른 모듈에 대해 꼭 필요한 지식만 알고 있다면 두 모듈은 낮은 결합도를 가진다.
* 결합도가 높으면 함께 변경해야 하는 모듈의 수가 늘어나기에 변경이 어려워진다.


<br>

<img alt="image" height="200" src="https://github.com/reddevilmidzy/CS-Study/assets/78539407/ef96aeb5-2688-4896-93aa-c595b6ec15ea"/>

<br>

## 객체지향의 장단점

### 장점

* 변경에 유연하게 대응할 수 있는 구조를 갖게 되어 유지보수하기 쉬워진다
* 코드의 재사용성을 높일 수 있다.
* 객체 단위로 코드를 작성하기 때문에 디버깅이 쉽다.
 

### 단점

* 프로그램이 커질 경우 객체간의 관계를 파악하기 어렵다.
* 규모가 작은 프로젝트에서 객체지향을 적용한다면 오히려 가독성을 저하시킬 수 있다.
* 추상화와 다형성 등의 기능을 제공하기 위해 런타임에서 추가적인 작업을 수행해야 하기에 일부 경우에는 성능 오버헤드가 발생할 수 있다.

<br>

## 객체지향 언어

대표적인 객체지향 프로그래밍 언어는 아래와 같다.

* 시뮬라 67
* 스몰토크
* 오브젝티브-C
* C++
* C#
* 자바
* 객체지향 파스칼
* 파이썬
* 루비

<br>

<br>

---

#### ref

* [위키백과 - 객체지향 프로그래밍](https://ko.wikipedia.org/wiki/%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)
* [역할, 책임, 협력](https://lazypazy.tistory.com/250)
* [[오브젝트] 4장 설계 품질과 트레이드오프](https://lazypazy.tistory.com/252)
