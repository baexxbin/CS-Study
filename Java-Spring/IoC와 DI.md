# Ioc와 DI

<br/>

## 객체지향 설계와 스프링

- 스프링을 사용하기 전
  - 순수하게 자바로 OCP, DIP 원칙을 지키면서 개발해보면, 결국 스프링 프레임워크를 만들게 됨(정확히는 DI 컨테이너)
- 스프링은 `다형성`을 극대화해서 역할과 구현을 편리하게 다룰 수 있도록 지원함
  - 의존관계 주입(`DI`), `DI 컨테이너` 기술로 `OCP`와 `DIP`를 가능하게 지원함
  - 클라이언트 코드의 변경 없이 기능 확장 가능

<br/>

### 제어의 역전 `IoC`(Inversion of Control)
- 기존 프로그램은 구현 객체가 프로그램의 제어 흐름을 스스로 조종했음
- AppConfig가 등장한 이후에 구현 객체는 자신의 로직을 실행하는 역할만 담당
  - 프로그램의 제어 흐름에 대한 권한은 모두 AppConfig가 가짐
- 프로그램의 제어 흐름을 직접 제어하는 것이 아니라 **외부에서 관리하는 것**을 `제어의 역전(IoC)`라고 함
  - 프레임워크(작성한 코드를 대신 제어하고 실행), 라이브러리(작성한 코드를 직접 제어하고 실행)


<br/>

#### AppConfig
- 애플리케이션의 전체 동작 방식을 구성하기 위해, 구현 객체를 생성하고 연결하는 책임을 가지는 별도의 설정 클래스
    - 실제 동작에 필요한 구현 객체를 생성
    - 생성한 객체 인스턴스의 참초(레퍼런스)를 생성자를 통해서 주입
- 클라이언트 입장에서 보면 의존 관계를 마치 외부에서 주입 해주는 것 같다고 해서 `DI - 의존 관계 주입(의존성 주입)`이라고 함
- AppConfig의 등장으로 애플리케이션이 크게 사용 영역과, 객체를 생성하고 구성(`Configuration`)하는 영역으로 분리됨


<br/>

### 의존관계 주입 `DI`(Dependency Injection)
- 애플리케이션 **실행 시점(런타임)** 에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결 되는 것
  - 객체 인스턴스를 생성하고, 그 참조 값을 전달해서 연결됨
- 의존관계는 **정적인 클래스 의존 관계**와, 실행 시점에 결정되는 **동적인 객체(인스턴스) 의존 관계** 둘을 분리해서 생각해야 함
  - 정적인 클래스 의존 관계: 애플리케이션을 실행하지 않아도 분석 가능
  - 동적인 객체(인스턴스) 의존 관계: 애플리케이션 실행 시점에 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계
- 의존 관계 주입을 사용
  - 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있음
  - 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체(인스턴스) 의존관계를 쉽게 변경할 수 있음

<br/>

**IoC, DI 컨테이너**
- AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 `IoC 컨테이너` 또는 `DI 컨테이너`라 함
- 의존관계 주입에 초점을 맞추어 최근에는 주로 `DI 컨테이너`라 함


<br/>

## 스프링 컨테이너와 스프링 빈

```
Spring Container: 스프링에서 자바 객체들을 관리하는 공간
Spring Bean: 스프링에 의해 생성되고 관리되는 자바 객체
```
  
<br/>

### 스프링 컨테이너

- 기존 방법
    - 개발자가 `AppConfig`를 사용해서 직접 객체를 생성하고 DI 했음
    - 개발자가 필요한 객체를 `AppConfig`를 사용해서 직접 조회했음
    - 자바 코드로 모든 것을 직접함
- 스프링 컨테이너는 `@Configuration`이 붙은 `AppConfig`를 설정(구성)정보로 사용함
    - `@Bean`이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록함
        - 스프링 컨테이너에 등록된 객체를 `스프링 빈`이라고 함
        - 스프링 빈은 `@Bean`이 붙은 메서드의 명을 스프링 빈의 이름으로 사용
    - 스프링 컨테이너를 통해 객체를 `스프링 빈`으로 등록하고, `스프링 빈(객체)`을 찾음
        - 스프링 빈은 `applicationContext.getBean()` 메서드를 사용해서 찾을 수 있음
- `ApplicationContext`를 스프링 컨테이너라고 하며, 인터페이스임
  - XML 기반으로 만들 수 있고, 애노테이션 기반의 자바 설정 클래스로 만들 수 있음
    - `AppConfig` : 애노테이션 기반의 자바 설정 클래스로 만든 스프링 컨테이너

<br/>

### 스프링 빈

  - 스프링 컨테이너에 의해 관리되는 재사용 가능한 소프트웨어 컴포넌트
  - 인스턴스화된 객체를 의미하며, 스프링 컨테이너에 등록된 객체

<br/>


#### 스프링 빈을 스프링 컨테이너에 등록하는 방법

1. 자바 코드로 직접 스프링 빈 등록
    - `@Bean` 어노테이션 또는 xml 설정의 `<bean>`을 통해 설정 정보에 직접 등록
      - `@Configuration` 구성 정보에 `@Bean` 어노테이션을 통해 스프링 컨테이너에 직접 빈으로 등록
      - XML로 스프링 빈을 등록하는 방법은 최근에 거의 사용하지 않음
    - 스프링 빈이 많아지면 설정 정보가 커지면서 동시에 누락하는 문제가 발생할 수 있음
2. 컴포넌트 스캔과 자동 의존관계 설정(`@ComponentScan`, `@Component`)
    - 빈 객체로 등록하고 싶은 클래스에 `@Component` 어노테이션을 추가히면, 컴포넌트 스캔의 대상이 됨
    - `@ComponentScan`을 `@Configuration`이 붙은 설정 정보 클래스에 붙여 `@Component` 애노테이션이 붙은 클래스를 스캔해서 스프링 빈으로 등록함

<br/>

#### 빈 생명주기(Bean LifeCycle)

- 스프링 컨테이너는 Bean 객체들을 책임지고 의존성을 관리함
  - 객체의 생성부터 소멸까지의 생명주기를 개발자가 아닌 컨테이너가 관리함 
- 스프링 빈 이벤트 라이프 사이클
  - `스프링 IoC 컨테이너 생성 → 스프링 빈 생성 → 의존관계 주입 → 초기화 콜백 메소드 호출 → 사용 → 소멸 전 콜백 메소드 호출 → 스프링 종료`
  - 간단하게 `객체 생성 → 의존관계 주입`이라는 라이프 사이클을 가짐
- 빈 생명주기 콜백의 필요성
  - 결국 스프링 빈은 객체를 생성하고, 의존관계 주입이 모두 다 끝나야 필요한 데이터를 사용할 수 있는 준비가 완료됨
  - 따라서 초기화 작업은 의존관계 주입이 모두 완료되고 호출되어야 하기 때문에 개발자는 이 시점을 알고있어야 함
- 스프링의 빈 생명주기 콜백 함수 지원 
  - 스프링은 의존관계 주입이 완료되면 스프링 빈에게 콜백 메서드를 통해서 초기화 시점을 알려주는 다양한 기능을 제공함
  - 스프링 컨테이너가 종료되기 직전에도 소멸 콜백을 주어 안전하게 종료작업을 진행할 수 있음
  - 빈 생명주기 콜백 함수
    1. 인터페이스(`InitializingBean`, `DisposableBean`)
    2. 설정 정보에 초기화 메소드, 종료 메소드 지정(`@Bean(initMethod = "init", destroyMethod = "close")`)
    3. `@PostConstruct`, `@PreDestroy` 어노테이션 지원


<br/>

#### 스프링 빈 스코프

- 빈 스코프는 빈이 존재할 수 있는 범위를 뜻함
- 스프링은 다양한 스코프를 지원함
  - 싱글톤 스코프
    - 기본 스코프로 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프
    - 싱글톤 스코프의 빈을 조회하면 스프링 컨테이너는 항상 같은 인스턴스의 빈을 반환함
      - 같은 요청이 와도 같은 객체 인스턴스의 스프링 빈을 반환함
  - 프로토타입 스코프
    - 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입 그리고 초기화까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프
    - 프로토타입 스코프의 빈은 조회하면 스프링 컨테이너는 항상 새로운 인스턴스를 생성해서 반환함
      - 같은 요청이 오면 항상 새로운 프로토타입 빈을 생성해서 반환함
  - 웹 관련 스코프: 웹 환경에서만 동작하고, 프로토타입과 다르게 스프링이 해당 스코프의 종료지점까지 관리함
    - request: HTTP 요청 하나가 들어오고 나갈 때까지 유지되는 스코프로, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고 관리됨
    - session: 웹 세션이 생성되고 종료될 때까지 유지되는 스코프(HTTP Session과 동일한 생명주기를 가짐)
    - application: 웹의 서블릿 컨텍스트(ServletContext)와 같은 범위로 유지되는 스코프
    - websocket: 웹 소켓과 동일한 생명주기를 가짐